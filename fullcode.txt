(Files content cropped to 300k characters, download full ingest to see more)
================================================
File: README.md
================================================
# CodeInsight

CodeInsight is a web application that enhances code understanding by leveraging AI to analyze GitHub repositories. It provides intelligent code analysis, vulnerability scanning, and interactive visualizations.

## Features

- GitHub repository analysis with AI-powered insights
- Security vulnerability scanning
- Interactive code visualization dashboard
- User management with GitHub authentication
- Shareable analysis reports

## Tech Stack

- Frontend: React + TypeScript
- Backend: Node.js + TypeScript
- Database: MongoDB + Redis
- AI: Claude API
- Authentication: GitHub OAuth

## Project Structure

```
codeinsight/
├── client/      # React frontend
├── server/      # Node.js backend
├── common/      # Shared code
└── docker/      # Docker configuration
```

## Getting Started

1. Install dependencies:
```bash
npm install
```

2. Set up environment variables:
```bash
# Create .env files in client/ and server/ directories
cp client/.env.example client/.env
cp server/.env.example server/.env
```

3. Start development servers:
```bash
npm run dev
```

## Development Guidelines

- Follow TypeScript best practices and maintain strict type safety
- Write unit tests for all new components
- Document API endpoints and component interfaces
- Handle errors gracefully with proper error boundaries
- Follow security best practices for API keys and authentication
- Keep components modular and reusable

## Security

- Never commit API keys or secrets
- Use environment variables for sensitive data
- Implement proper input validation
- Follow OAuth security best practices
- Regular security audits with vulnerability scanning

## Contributing

1. Create a feature branch
2. Make your changes
3. Write/update tests
4. Submit a pull request

## License

MIT



================================================
File: app.json
================================================
{
  "name": "CodeIngest",
  "description": "A tool for code analysis and insights",
  "repository": "https://github.com/yourusername/CodeIngest",
  "keywords": ["node", "express", "static"],
  "env": {
    "NODE_ENV": {
      "description": "Environment setting",
      "value": "production"
    }
  },
  "buildpacks": [
    {
      "url": "heroku/nodejs"
    }
  ]
}



================================================
File: Architecture.txt
================================================
CodeIngest - Architecture

codeinsight/
├── .github/ # GitHub workflows and configuration
│ └── workflows/
│ ├── ci.yml
│ └── deploy.yml
├── client/ # Frontend React application
│ ├── public/
│ │ ├── index.html
│ │ └── assets/
│ ├── src/
│ │ ├── components/ # React components
│ │ │ ├── auth/ # Authentication components
│ │ │ ├── dashboard/ # Dashboard components
│ │ │ ├── repository/ # Repository related components
│ │ │ ├── analysis/ # Analysis result components
│ │ │ └── common/ # Shared components
│ │ ├── hooks/ # Custom React hooks
│ │ ├── services/ # API service modules
│ │ │ ├── api.ts # Base API configuration
│ │ │ ├── auth.service.ts # Authentication services
│ │ │ ├── repo.service.ts # Repository services
│ │ │ └── analysis.service.ts # Analysis services
│ │ ├── store/ # State management
│ │ │ ├── slices/ # Redux slices or context providers
│ │ │ └── store.ts # Store configuration
│ │ ├── types/ # TypeScript type definitions
│ │ ├── utils/ # Utility functions
│ │ ├── App.tsx # Main App component
│ │ └── index.tsx # Entry point
│ ├── .eslintrc.js
│ ├── tsconfig.json
│ └── package.json
├── server/ # Backend Node.js application
│ ├── src/
│ │ ├── controllers/ # Request handlers
│ │ │ ├── auth.controller.ts
│ │ │ ├── repo.controller.ts
│ │ │ └── analysis.controller.ts
│ │ ├── services/ # Business logic
│ │ │ ├── auth.service.ts
│ │ │ ├── repo.service.ts
│ │ │ ├── github.service.ts # GitHub API integration
│ │ │ ├── claude.service.ts # Claude API integration
│ │ │ └── analysis.service.ts
│ │ ├── models/ # Data models
│ │ │ ├── user.model.ts
│ │ │ ├── repository.model.ts
│ │ │ └── analysis.model.ts
│ │ ├── middleware/ # Express middleware
│ │ │ ├── auth.middleware.ts
│ │ │ ├── error.middleware.ts
│ │ │ └── rate-limit.middleware.ts
│ │ ├── utils/ # Utility functions
│ │ │ ├── git.utils.ts # Git operations
│ │ │ ├── file.utils.ts # File handling
│ │ │ └── prompt.utils.ts # Claude prompt engineering
│ │ ├── config/ # Configuration
│ │ │ ├── env.config.ts
│ │ │ ├── db.config.ts
│ │ │ └── api.config.ts
│ │ ├── routes/ # API routes
│ │ │ ├── auth.routes.ts
│ │ │ ├── repo.routes.ts
│ │ │ └── analysis.routes.ts
│ │ └── app.ts # Main application setup
│ ├── .eslintrc.js
│ ├── tsconfig.json
│ └── package.json
├── common/ # Shared code between client and server
│ ├── src/
│ │ ├── types/ # Shared type definitions
│ │ └── constants/ # Shared constants
│ ├── tsconfig.json
│ └── package.json
├── scripts/ # Development and build scripts
│ ├── setup.sh
│ └── deploy.sh
├── docker/ # Docker configuration
│ ├── Dockerfile.client
│ ├── Dockerfile.server
│ └── docker-compose.yml
├── .gitignore
├── package.json # Root package.json for workspaces
├── README.md
└── tsconfig.json # Base TypeScript configuration



================================================
File: fullcode.txt
================================================
================================================
File: README.md
================================================
# CodeInsight

CodeInsight is a web application that enhances code understanding by leveraging AI to analyze GitHub repositories. It provides intelligent code analysis, vulnerability scanning, and interactive visualizations.

## Features

- GitHub repository analysis with AI-powered insights
- Security vulnerability scanning
- Interactive code visualization dashboard
- User management with GitHub authentication
- Shareable analysis reports

## Tech Stack

- Frontend: React + TypeScript
- Backend: Node.js + TypeScript
- Database: MongoDB + Redis
- AI: Claude API
- Authentication: GitHub OAuth

## Project Structure

```
codeinsight/
├── client/      # React frontend
├── server/      # Node.js backend
├── common/      # Shared code
└── docker/      # Docker configuration
```

## Getting Started

1. Install dependencies:
```bash
npm install
```

2. Set up environment variables:
```bash
# Create .env files in client/ and server/ directories
cp client/.env.example client/.env
cp server/.env.example server/.env
```

3. Start development servers:
```bash
npm run dev
```

## Development Guidelines

- Follow TypeScript best practices and maintain strict type safety
- Write unit tests for all new components
- Document API endpoints and component interfaces
- Handle errors gracefully with proper error boundaries
- Follow security best practices for API keys and authentication
- Keep components modular and reusable

## Security

- Never commit API keys or secrets
- Use environment variables for sensitive data
- Implement proper input validation
- Follow OAuth security best practices
- Regular security audits with vulnerability scanning

## Contributing

1. Create a feature branch
2. Make your changes
3. Write/update tests
4. Submit a pull request

## License

MIT



================================================
File: Architecture.txt
================================================
CodeIngest - Architecture

codeinsight/
├── .github/ # GitHub workflows and configuration
│ └── workflows/
│ ├── ci.yml
│ └── deploy.yml
├── client/ # Frontend React application
│ ├── public/
│ │ ├── index.html
│ │ └── assets/
│ ├── src/
│ │ ├── components/ # React components
│ │ │ ├── auth/ # Authentication components
│ │ │ ├── dashboard/ # Dashboard components
│ │ │ ├── repository/ # Repository related components
│ │ │ ├── analysis/ # Analysis result components
│ │ │ └── common/ # Shared components
│ │ ├── hooks/ # Custom React hooks
│ │ ├── services/ # API service modules
│ │ │ ├── api.ts # Base API configuration
│ │ │ ├── auth.service.ts # Authentication services
│ │ │ ├── repo.service.ts # Repository services
│ │ │ └── analysis.service.ts # Analysis services
│ │ ├── store/ # State management
│ │ │ ├── slices/ # Redux slices or context providers
│ │ │ └── store.ts # Store configuration
│ │ ├── types/ # TypeScript type definitions
│ │ ├── utils/ # Utility functions
│ │ ├── App.tsx # Main App component
│ │ └── index.tsx # Entry point
│ ├── .eslintrc.js
│ ├── tsconfig.json
│ └── package.json
├── server/ # Backend Node.js application
│ ├── src/
│ │ ├── controllers/ # Request handlers
│ │ │ ├── auth.controller.ts
│ │ │ ├── repo.controller.ts
│ │ │ └── analysis.controller.ts
│ │ ├── services/ # Business logic
│ │ │ ├── auth.service.ts
│ │ │ ├── repo.service.ts
│ │ │ ├── github.service.ts # GitHub API integration
│ │ │ ├── claude.service.ts # Claude API integration
│ │ │ └── analysis.service.ts
│ │ ├── models/ # Data models
│ │ │ ├── user.model.ts
│ │ │ ├── repository.model.ts
│ │ │ └── analysis.model.ts
│ │ ├── middleware/ # Express middleware
│ │ │ ├── auth.middleware.ts
│ │ │ ├── error.middleware.ts
│ │ │ └── rate-limit.middleware.ts
│ │ ├── utils/ # Utility functions
│ │ │ ├── git.utils.ts # Git operations
│ │ │ ├── file.utils.ts # File handling
│ │ │ └── prompt.utils.ts # Claude prompt engineering
│ │ ├── config/ # Configuration
│ │ │ ├── env.config.ts
│ │ │ ├── db.config.ts
│ │ │ └── api.config.ts
│ │ ├── routes/ # API routes
│ │ │ ├── auth.routes.ts
│ │ │ ├── repo.routes.ts
│ │ │ └── analysis.routes.ts
│ │ └── app.ts # Main application setup
│ ├── .eslintrc.js
│ ├── tsconfig.json
│ └── package.json
├── common/ # Shared code between client and server
│ ├── src/
│ │ ├── types/ # Shared type definitions
│ │ └── constants/ # Shared constants
│ ├── tsconfig.json
│ └── package.json
├── scripts/ # Development and build scripts
│ ├── setup.sh
│ └── deploy.sh
├── docker/ # Docker configuration
│ ├── Dockerfile.client
│ ├── Dockerfile.server
│ └── docker-compose.yml
├── .gitignore
├── package.json # Root package.json for workspaces
├── README.md
└── tsconfig.json # Base TypeScript configuration



================================================
File: Spec.txt
================================================
CodeIngest - Spec

Specification for Your Enhanced Version

Product Name: CodeInsight

Product Overview

CodeInsight is a web application that enhances code understanding by leveraging AI to analyze GitHub repositories. Users authenticate with GitHub to access both public and private repositories, then CodeInsight processes the codebase through Claude AI to produce insights, vulnerability reports, and product specifications.

Core Features

1. GitHub Authentication
     - OAuth integration with GitHub
    - Access to private and public repositories
    - User profile and repository management

1. Repository Ingestion
     - Clone and analyze GitHub repositories
    - Smart filtering of files (by patterns, size, and type)
    - Efficient handling of large codebases

1. AI Analysis with Claude
     - Code review with best practices assessment
    - Security vulnerability scanning
    - Identification of key files and components
    - Generation of product specifications

1. Visualization
     - Interactive file tree navigator
    - Code structure visualization
    - Key insights dashboard
    - Exportable reports in multiple formats

1. User Management
     - Save analysis history
    - Favorite repositories
    - Share analysis results

User Flow

6. User logs in with GitHub credentials
7. User selects a repository to analyze
8. System clones and processes the repository
9. Claude AI analyzes the codebase
10. System presents results in an interactive dashboard
11. User can explore detailed reports, share results, or export specifications

Technical Requirements

12. Frontend
     - React with TypeScript
    - Modern UI library (e.g., Material UI or Chakra UI)
    - Responsive design for mobile and desktop

1. Backend
     - Node.js with TypeScript
    - Express or NestJS framework
    - RESTful API architecture

1. Authentication
     - GitHub OAuth integration
    - JWT token-based authentication
    - Secure credential handling

1. AI Integration
     - Anthropic Claude API integration
    - Efficient content chunking for large repositories
    - Prompt engineering for code analysis

1. Data Storage
     - MongoDB for user data and analysis results
    - Redis for caching and rate-limiting
    - Temporary file storage for repository processing

1. Deployment
     - Docker containerization
    - Cloud hosting (AWS, GCP, or Azure)
    - CI/CD pipeline



================================================
File: github-oauth-setup.md
================================================
# GitHub OAuth Setup Instructions

## 1. Update Server Environment (.env file)

Replace the contents of `/server/.env` with the following, using your GitHub credentials:

```
# Server Configuration
PORT=3030
NODE_ENV=development

# Database Configuration
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/codeinsight

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=Ov23li8iXRzrnU6OV2Ya
GITHUB_CLIENT_SECRET=8a90bc07534609020fbe78187d47bf8d486912bd
GITHUB_CALLBACK_URL=http://localhost:3030/api/auth/github/callback

# Claude AI Configuration
CLAUDE_API_KEY=your_claude_api_key

# JWT Configuration
JWT_SECRET=use_a_secure_random_string_at_least_32_chars
JWT_EXPIRES_IN=7d

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000  # 15 minutes
RATE_LIMIT_MAX_REQUESTS=100
```

## 2. Update Client Environment

Update `/client/.env.development` with your GitHub client ID:

```
# API Configuration
REACT_APP_API_URL=http://localhost:3030/api

# GitHub OAuth Configuration
REACT_APP_GITHUB_CLIENT_ID=Ov23li8iXRzrnU6OV2Ya
```

Make sure to replace `your_claude_api_key` and `use_a_secure_random_string_at_least_32_chars` with the actual values from your Claude AI application and a secure random string respectively.



================================================
File: package.json
================================================
{
  "name": "codeinsight",
  "version": "1.0.0",
  "private": true,
  "workspaces": [
    "client",
    "server",
    "common"
  ],
  "scripts": {
    "client": "npm run start --workspace client",
    "server": "npm run start --workspace server",
    "dev": "concurrently \"npm run server\" \"npm run client\"",
    "build": "npm run build --workspaces",
    "install:all": "npm install && npm install --workspace client && npm install --workspace server"
  },
  "devDependencies": {
    "concurrently": "^8.2.2",
    "typescript": "^5.3.3"
  }
}



================================================
File: reverence.txt
================================================

Entrypoint

async def ingest_async(
    source: str,
    max_file_size: int = 10 * 1024 * 1024,  # 10 MB
    include_patterns: Optional[Union[str, Set[str]]] = None,
    exclude_patterns: Optional[Union[str, Set[str]]] = None,
    branch: Optional[str] = None,
    output: Optional[str] = None,
) -> Tuple[str, str, str]:
    """
    Main entry point for ingesting a source and processing its contents.
    """
    repo_cloned = False

    try:
        query: IngestionQuery = await parse_query(
            source=source,
            max_file_size=max_file_size,
            from_web=False,
            include_patterns=include_patterns,
            ignore_patterns=exclude_patterns,
        )

        if query.url:
            selected_branch = branch if branch else query.branch  # prioritize branch argument
            query.branch = selected_branch

            clone_config = query.extract_clone_config()
            clone_coroutine = clone(clone_config)

            if inspect.iscoroutine(clone_coroutine):
                if asyncio.get_event_loop().is_running():
                    await clone_coroutine
                else:
                    asyncio.run(clone_coroutine)
            else:
                raise TypeError("clone did not return a coroutine as expected.")

            repo_cloned = True

        summary, tree, content = ingest_query(query)

        if output is not None:
            with open(output, "w", encoding="utf-8") as f:
                f.write(tree + "\n" + content)

        return summary, tree, content
    finally:
        # Clean up the temporary directory if it was created
        if repo_cloned:
            shutil.rmtree(TMP_BASE_PATH, ignore_errors=True)

            =====================================================
            =====================================================


    Ingestion 

    def ingest_query(query: IngestionQuery) -> Tuple[str, str, str]:
    """
    Run the ingestion process for a parsed query.
    """
    subpath = Path(query.subpath.strip("/")).as_posix()
    path = query.local_path / subpath

    apply_gitingest_file(path, query)

    if not path.exists():
        raise ValueError(f"{query.slug} cannot be found")

    if (query.type and query.type == "blob") or query.local_path.is_file():
        # Handle single file case
        if not path.is_file():
            raise ValueError(f"Path {path} is not a file")

        relative_path = path.relative_to(query.local_path)

        file_node = FileSystemNode(
            name=path.name,
            type=FileSystemNodeType.FILE,
            size=path.stat().st_size,
            file_count=1,
            path_str=str(relative_path),
            path=path,
        )

        if not file_node.content:
            raise ValueError(f"File {file_node.name} has no content")

        return format_node(file_node, query)

    # Handle directory case
    root_node = FileSystemNode(
        name=path.name,
        type=FileSystemNodeType.DIRECTORY,
        path_str=str(path.relative_to(query.local_path)),
        path=path,
    )

    stats = FileSystemStats()

    _process_node(
        node=root_node,
        query=query,
        stats=stats,
    )

    return format_node(root_node, query)

    ===============================================================
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    cloning 

    @async_timeout(TIMEOUT)
async def clone(config: CloneConfig) -> None:
    """
    Clone a repository to a local path based on the provided configuration.
    """
    # Extract and validate query parameters
    url: str = config.url
    local_path: str = config.local_path
    commit: Optional[str] = config.commit
    branch: Optional[str] = config.branch
    partial_clone: bool = config.subpath != "/"

    # Create parent directory if it doesn't exist
    parent_dir = Path(local_path).parent
    try:
        os.makedirs(parent_dir, exist_ok=True)
    except OSError as exc:
        raise OSError(f"Failed to create parent directory {parent_dir}: {exc}") from exc

    # Check if the repository exists
    if not await _check_repo_exists(url):
        raise ValueError("Repository not found, make sure it is public")

    clone_cmd = ["git", "clone", "--single-branch"]
    # TODO re-enable --recurse-submodules

    if partial_clone:
        clone_cmd += ["--filter=blob:none", "--sparse"]

    if not commit:
        clone_cmd += ["--depth=1"]
        if branch and branch.lower() not in ("main", "master"):
            clone_cmd += ["--branch", branch]

    clone_cmd += [url, local_path]

    # Clone the repository
    await _run_command(*clone_cmd)

    if commit or partial_clone:
        checkout_cmd = ["git", "-C", local_path]

        if partial_clone:
            subpath = config.subpath.lstrip("/")
            if config.blob:
                # When ingesting from a file url (blob/branch/path/file.txt), we need to remove the file name.
                subpath = str(Path(subpath).parent.as_posix())

            checkout_cmd += ["sparse-checkout", "set", subpath]

        if commit:
            checkout_cmd += ["checkout", commit]

        # Check out the specific commit and/or subpath
        await _run_command(*checkout_cmd)


        ====================================================================
        ====================================================================

        logic for inclusion or not in ingestion 

        def _should_include(path: Path, base_path: Path, include_patterns: Set[str]) -> bool:
    """
    Determine if the given file or directory path matches any of the include patterns.
    """
    try:
        rel_path = path.relative_to(base_path)
    except ValueError:
        # If path is not under base_path at all
        return False

    rel_str = str(rel_path)
    if path.is_dir():
        rel_str += "/"

    for pattern in include_patterns:
        if fnmatch(rel_str, pattern):
            return True
    return False


def _should_exclude(path: Path, base_path: Path, ignore_patterns: Set[str]) -> bool:
    """
    Determine if the given file or directory path matches any of the ignore patterns.
    """
    try:
        rel_path = path.relative_to(base_path)
    except ValueError:
        # If path is not under base_path at all
        return True

    rel_str = str(rel_path)
    for pattern in ignore_patterns:
        if pattern and fnmatch(rel_str, pattern):
            return True
    return False

    ===================================
    ===================================

    Processing node of files 

    def _process_node(
    node: FileSystemNode,
    query: IngestionQuery,
    stats: FileSystemStats,
) -> None:
    """
    Process a file or directory item within a directory.
    """
    if limit_exceeded(stats, node.depth):
        return

    for sub_path in node.path.iterdir():
        symlink_path = None
        if sub_path.is_symlink():
            if not _is_safe_symlink(sub_path, query.local_path):
                print(f"Skipping unsafe symlink: {sub_path}")
                continue

            symlink_path = sub_path
            sub_path = sub_path.resolve()

        if sub_path in stats.visited:
            print(f"Skipping already visited path: {sub_path}")
            continue

        stats.visited.add(sub_path)

        if query.ignore_patterns and _should_exclude(sub_path, query.local_path, query.ignore_patterns):
            continue

        if query.include_patterns and not _should_include(sub_path, query.local_path, query.include_patterns):
            continue

        if sub_path.is_file():
            _process_file(path=sub_path, parent_node=node, stats=stats, local_path=query.local_path)
        elif sub_path.is_dir():
            child_directory_node = FileSystemNode(
                name=sub_path.name,
                type=FileSystemNodeType.DIRECTORY,
                path_str=str(sub_path.relative_to(query.local_path)),
                path=sub_path,
                depth=node.depth + 1,
            )

            # rename the subdir to reflect the symlink name
            if symlink_path:
                child_directory_node.name = symlink_path.name
                child_directory_node.path_str = str(symlink_path)

            _process_node(
                node=child_directory_node,
                query=query,
                stats=stats,
            )
            node.children.append(child_directory_node)
            node.size += child_directory_node.size
            node.file_count += child_directory_node.file_count
            node.dir_count += 1 + child_directory_node.dir_count

        else:
            raise ValueError(f"Unexpected error: {sub_path} is neither a file nor a directory")

    node.sort_children()

    Understanding the App Size
You're absolutely right that the core ingestion logic is not overly complex. The reason the original app is large is because it handles several aspects beyond just ingestion:

Multiple interfaces: CLI, Python module, and web application
Error handling and edge cases: Dealing with various repository hosts, file types, encodings
Server components: Web routing, templating, API endpoints
Caching and optimization: For handling large repositories efficiently
Output formatting: For making the content LLM-friendly

For your TypeScript/React version, you could simplify this considerably by focusing on:

GitHub authentication
Repository cloning (using a Git library for Node.js)
File traversal and filtering (similar to the Python code above)
Claude API integration for the analysis

The core logic can be translated to TypeScript, and many of the web application concerns can be handled by React and modern web frameworks.
Would you like me to focus on implementing just this core ingestion logic in TypeScript? That would be a more manageable first step.


================================================
File: setup-env.sh
================================================
#!/bin/bash

# Create server .env file with placeholder values
cat > ./server/.env << EOL
# Server Configuration
PORT=3000
NODE_ENV=development

# Database Configuration
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/codeinsight
REDIS_URL=redis://localhost:6379

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=placeholder_github_id
GITHUB_CLIENT_SECRET=placeholder_github_secret
GITHUB_CALLBACK_URL=http://localhost:3000/api/auth/github/callback

# Claude AI Configuration
ANTHROPIC_API_KEY=placeholder_anthropic_key
CLAUDE_API_KEY=placeholder_claude_key

# JWT Configuration
JWT_SECRET=temporary_dev_jwt_secret_at_least_32_chars_long
JWT_EXPIRES_IN=7d

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
EOL

# Create client .env file
cat > ./client/.env.development << EOL
# API Configuration
REACT_APP_API_URL=http://localhost:3000/api

# GitHub OAuth Configuration
REACT_APP_GITHUB_CLIENT_ID=placeholder_github_id
EOL

echo "Environment files created with placeholder values"
echo "Please update with your actual credentials before running in production"



================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "exclude": ["node_modules"]
}



================================================
File: .npmrc
================================================
legacy-peer-deps=true
node-linker=hoisted
public-hoist-pattern[]=*



================================================
File: client/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; connect-src 'self' localhost:* ws:; font-src 'self' data: https: http:; img-src 'self' data: https: http:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
    />
    <meta
      name="description"
      content="CodeInsight - AI-powered code analysis and understanding"
    />
    <link rel="apple-touch-icon" href="/logo192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>CodeInsight</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>



================================================
File: client/jest.config.js
================================================
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  testMatch: ['**/__tests__/**/*.test.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.json',
    },
  },
};



================================================
File: client/package.json
================================================
{
  "name": "@codeinsight/client",
  "version": "1.0.0",
  "private": true,
  "dependencies": {
    "@chakra-ui/react": "^2.8.2",
    "@emotion/react": "^11.11.3",
    "@emotion/styled": "^11.11.0",
    "@tanstack/react-query": "^5.22.2",
    "axios": "^1.6.7",
    "framer-motion": "^11.0.5",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-icons": "^5.0.1",
    "react-router-dom": "^6.22.1",
    "typescript": "^5.3.3",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@jest/globals": "^29.7.0",
    "@testing-library/jest-dom": "^6.4.2",
    "@testing-library/react": "^14.2.1",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.11.19",
    "@types/react": "^18.2.57",
    "@types/react-dom": "^18.2.19",
    "@typescript-eslint/eslint-plugin": "^7.0.2",
    "@typescript-eslint/parser": "^7.0.2",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^8.56.0",
    "eslint-plugin-react": "^7.33.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.1.2",
    "vite": "^6.2.2"
  },
  "scripts": {
    "start": "vite --port 3001",
    "build": "vite build",
    "dev": "vite --port 3001",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch",
    "clean": "rm -rf node_modules package-lock.json",
    "reinstall": "npm run clean && npm install"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}



================================================
File: client/tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "axios": ["node_modules/axios/index.d.ts"]
    },
    "typeRoots": ["./node_modules/@types", "./src/types"]
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}



================================================
File: client/tsconfig.node.json
================================================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}



================================================
File: client/vite.config.ts
================================================
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
  server: {
    port: 3001,
    strictPort: true,
    proxy: {
      '/api': {
        target: 'http://localhost:3030',
        changeOrigin: true,
      },
    },
    // Enable history API fallback to ensure client-side routing works
    historyApiFallback: true,
  },
  // Ensure React Router works properly
  base: '/',
});



================================================
File: client/.env.development
================================================
# API Configuration
REACT_APP_API_URL=http://localhost:3030/api

# GitHub OAuth Configuration
REACT_APP_GITHUB_CLIENT_ID=Ov23li8iXRzrnU6OV2Ya



================================================
File: client/.env.example
================================================
# API Configuration
REACT_APP_API_URL=http://localhost:3000/api

# GitHub OAuth Configuration
REACT_APP_GITHUB_CLIENT_ID=your_github_client_id



================================================
File: client/public/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; connect-src 'self' localhost:* ws:; font-src 'self' data: https: http:; img-src 'self' data: https: http:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
    />
    <meta
      name="description"
      content="CodeInsight - AI-powered code analysis and understanding"
    />
    <link rel="apple-touch-icon" href="/logo192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>CodeInsight</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>



================================================
File: client/public/manifest.json
================================================
{
  "short_name": "CodeInsight",
  "name": "CodeInsight - AI-powered code analysis",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}



================================================
File: client/src/App.tsx
================================================
import { ChakraProvider, ColorModeScript } from '@chakra-ui/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { BrowserRouter } from 'react-router-dom';
import { theme } from './theme';
import { AppRoutes } from './routes';
import { AuthProvider } from './contexts/AuthContext';
import { Layout } from './components/Layout';

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      staleTime: 30000,
    },
  },
});

export function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <ChakraProvider theme={theme}>
        <ColorModeScript initialColorMode={theme.config.initialColorMode} />
        <BrowserRouter>
          <AuthProvider>
            <Layout>
              <AppRoutes />
            </Layout>
          </AuthProvider>
        </BrowserRouter>
      </ChakraProvider>
    </QueryClientProvider>
  );
}



================================================
File: client/src/index.tsx
================================================
import React from 'react';
import { createRoot } from 'react-dom/client';
import { App } from './App';

const container = document.getElementById('root');
if (!container) {
  throw new Error('Failed to find the root element');
}

const root = createRoot(container);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);



================================================
File: client/src/routes.tsx
================================================
import { Routes, Route, Navigate } from 'react-router-dom';
import { DashboardPage } from './pages/DashboardPage';
import { LoginPage } from './pages/LoginPage';
import { RepositoryPage } from './pages/RepositoryPage';
import { AuthCallbackPage } from './pages/AuthCallbackPage';
import { useAuth } from './contexts/AuthContext';

export function AppRoutes() {
  const { isAuthenticated } = useAuth();

  return (
    <Routes>
      <Route
        path="/"
        element={
          isAuthenticated ? <DashboardPage /> : <Navigate to="/login" replace />
        }
      />
      <Route
        path="/login"
        element={isAuthenticated ? <Navigate to="/" replace /> : <LoginPage />}
      />
      <Route
        path="/auth/callback"
        element={<AuthCallbackPage />}
      />
      <Route
        path="/repository/:owner/:name"
        element={
          isAuthenticated ? <RepositoryPage /> : <Navigate to="/login" replace />
        }
      />
    </Routes>
  );
}



================================================
File: client/src/setupTests.ts
================================================
// Add any global test setup here
import '@testing-library/jest-dom';



================================================
File: client/src/theme.ts
================================================
import { extendTheme, type ThemeConfig } from '@chakra-ui/react';

const config: ThemeConfig = {
  initialColorMode: 'system',
  useSystemColorMode: true,
};

const colors = {
  brand: {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
  },
};

const components = {
  Button: {
    defaultProps: {
      colorScheme: 'brand',
    },
  },
  Card: {
    baseStyle: {
      container: {
        borderRadius: 'lg',
        boxShadow: 'sm',
      },
    },
  },
};

export const theme = extendTheme({
  config,
  colors,
  components,
  styles: {
    global: (props: any) => ({
      body: {
        bg: props.colorMode === 'dark' ? 'gray.900' : 'gray.50',
      },
    }),
  },
});



================================================
File: client/src/components/Layout.tsx
================================================
import {
  Box,
  Container,
  Flex,
  Heading,
  IconButton,
  Spacer,
  useColorMode,
  Avatar,
  Menu,
  MenuButton,
  MenuList,
  MenuItem,
  Spinner,
  Text,
  HStack,
} from '@chakra-ui/react';
import { FiMoon, FiSun, FiLogOut, FiGithub } from 'react-icons/fi';
import { useAuth } from '../contexts/AuthContext';
import { Link } from 'react-router-dom';

export function Layout({ children }: { children: React.ReactNode }) {
  const { colorMode, toggleColorMode } = useColorMode();
  const { user, isAuthenticated, isLoading, logout } = useAuth();
  const bgColor = colorMode === 'light' ? 'white' : 'gray.800';

  return (
    <Box minH="100vh" bg={colorMode === 'light' ? 'gray.50' : 'gray.900'}>
      <Flex
        as="header"
        bg={bgColor}
        py={4}
        px={8}
        shadow="sm"
        position="sticky"
        top={0}
        zIndex={1}
      >
        <HStack spacing={4}>
          <FiGithub size={24} />
          <Heading size="md" as={Link} to="/">
            CodeInsight
          </Heading>
        </HStack>
        <Spacer />
        <Flex gap={4} align="center">
          <IconButton
            aria-label="Toggle color mode"
            icon={colorMode === 'light' ? <FiMoon /> : <FiSun />}
            onClick={toggleColorMode}
            variant="ghost"
          />
          {isLoading ? (
            <Spinner size="sm" />
          ) : isAuthenticated && user ? (
            <Menu>
              <MenuButton>
                <HStack spacing={3}>
                  <Avatar size="sm" name={user.name} src={user.avatarUrl} />
                  <Text display={{ base: 'none', md: 'block' }}>{user.name}</Text>
                </HStack>
              </MenuButton>
              <MenuList>
                <MenuItem icon={<FiLogOut />} onClick={logout}>
                  Logout
                </MenuItem>
              </MenuList>
            </Menu>
          ) : null}
        </Flex>
      </Flex>
      <Box as="main" py={8}>
        <Container maxW="container.xl">
          {isLoading ? (
            <Flex justify="center" align="center" minH="50vh">
              <Spinner size="xl" />
            </Flex>
          ) : (
            children
          )}
        </Container>
      </Box>
    </Box>
  );
}



================================================
File: client/src/components/PublicRepositoryIngest.tsx
================================================
import React, { useState } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Input,
  VStack,
  Text,
  useToast,
  Flex,
  Divider,
  Heading,
  Alert,
  AlertIcon,
  AlertTitle,
  AlertDescription,
  CloseButton,
  useColorModeValue,
} from '@chakra-ui/react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

interface IngestResponse {
  repository: {
    id: string;
    owner: string;
    name: string;
  };
  analysisId: string;
  message: string;
}

export function PublicRepositoryIngest() {
  const [owner, setOwner] = useState('');
  const [repo, setRepo] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<IngestResponse | null>(null);
  const toast = useToast();
  const navigate = useNavigate();
  const formBg = useColorModeValue('white', 'gray.700');
  const borderColor = useColorModeValue('gray.200', 'gray.600');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!owner || !repo) {
      setError('Repository owner and name are required');
      return;
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      const response = await axios.post<IngestResponse>('http://localhost:3030/api/public-repositories', {
        owner,
        name: repo
      });
      
      setSuccess(response.data);
      toast({
        title: 'Repository ingested successfully',
        description: `${owner}/${repo} has been added and analysis has started.`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      
      // Clear form
      setOwner('');
      setRepo('');
    } catch (err) {
      const errorMessage = axios.isAxiosError(err) && err.response?.data?.error
        ? err.response.data.error
        : 'Failed to ingest repository. Please try again.';
      
      setError(errorMessage);
      toast({
        title: 'Error',
        description: errorMessage,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsLoading(false);
    }
  };
  
  const viewRepository = () => {
    if (success) {
      // Note: This is a mock navigation since we're not fully implementing the repository view
      // In a real app, we would navigate to the repository page
      toast({
        title: 'Viewing Repository',
        description: `Navigating to ${success.repository.owner}/${success.repository.name}`,
        status: 'info',
        duration: 3000,
        isClosable: true,
      });
    }
  };

  return (
    <Box 
      p={6} 
      borderWidth="1px" 
      borderRadius="lg" 
      borderColor={borderColor}
      bg={formBg}
      boxShadow="md"
      width="100%"
    >
      <VStack spacing={4} align="stretch">
        <Heading size="md">Try without logging in</Heading>
        <Text color="gray.500">
          Analyze any public GitHub repository instantly
        </Text>
        
        {error && (
          <Alert status="error" borderRadius="md">
            <AlertIcon />
            <AlertTitle mr={2}>Error:</AlertTitle>
            <AlertDescription>{error}</AlertDescription>
            <CloseButton 
              position="absolute" 
              right="8px" 
              top="8px" 
              onClick={() => setError(null)}
            />
          </Alert>
        )}
        
        {success && (
          <Alert status="success" borderRadius="md">
            <AlertIcon />
            <Box flex="1">
              <AlertTitle>Repository Ingested!</AlertTitle>
              <AlertDescription display="block">
                Analysis of {success.repository.owner}/{success.repository.name} is in progress.
              </AlertDescription>
            </Box>
            <Button 
              size="sm" 
              colorScheme="green" 
              onClick={viewRepository}
            >
              View Details
            </Button>
          </Alert>
        )}
        
        <form onSubmit={handleSubmit}>
          <VStack spacing={4}>
            <FormControl isRequired>
              <FormLabel>Repository Owner</FormLabel>
              <Input 
                placeholder="e.g., facebook" 
                value={owner}
                onChange={(e) => setOwner(e.target.value)}
              />
            </FormControl>
            
            <FormControl isRequired>
              <FormLabel>Repository Name</FormLabel>
              <Input 
                placeholder="e.g., react" 
                value={repo}
                onChange={(e) => setRepo(e.target.value)}
              />
            </FormControl>
            
            <Button 
              colorScheme="blue" 
              type="submit"
              isLoading={isLoading}
              loadingText="Ingesting"
              width="full"
            >
              Analyze Repository
            </Button>
          </VStack>
        </form>
      </VStack>
    </Box>
  );
}



================================================
File: client/src/components/SimpleRepositoryIngest.tsx
================================================
import { useState } from 'react';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Input,
  VStack,
  Text,
  useToast,
  Code,
  Heading,
  Spinner,
  Alert,
  AlertIcon,
  AlertTitle,
  AlertDescription,
  Divider,
} from '@chakra-ui/react';
import axios from 'axios';
import { useNavigate } from 'react-router-dom';

interface IngestResponse {
  repository: {
    id: string;
    owner: string;
    name: string;
  };
  analysisId?: string;
  message?: string;
}

export function SimpleRepositoryIngest() {
  const [repoUrl, setRepoUrl] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<IngestResponse | null>(null);
  const [logs, setLogs] = useState<string[]>([]);
  const toast = useToast();
  const navigate = useNavigate();

  const addLog = (message: string) => {
    setLogs(prev => [...prev, `[${new Date().toISOString()}] ${message}`]);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!repoUrl) {
      setError('Repository URL is required');
      return;
    }
    
    setIsLoading(true);
    setError(null);
    setLogs([]);
    addLog(`Starting repository ingestion for: ${repoUrl}`);
    
    try {
      // Send the full URL to the API
      addLog('Sending request to API with full GitHub URL...');
      const response = await axios.post<IngestResponse>('http://localhost:3030/api/public-repositories', {
        url: repoUrl
      });
      
      addLog(`API response received: ${JSON.stringify(response.data)}`);
      setSuccess(response.data);
      
      const repoData = response.data.repository;
      toast({
        title: 'Repository Ingested',
        description: `Successfully added ${repoData.owner}/${repoData.name} to your repositories`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      
      if (response.data.repository) {
        addLog(`Repository ingestion complete. Repository ID: ${response.data.repository.id}`);
        
        if (response.data.analysisId) {
          addLog(`Analysis started with ID: ${response.data.analysisId}`);
          addLog('Analysis results will be available shortly...');
        }
      }
    } catch (err: any) {
      const errorMessage = err.response?.data?.error || err.message || 'Failed to ingest repository';
      setError(errorMessage);
      addLog(`Error: ${errorMessage}`);
      
      toast({
        title: 'Ingestion Failed',
        description: errorMessage,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleViewRepository = () => {
    if (success?.repository) {
      navigate(`/repository/${success.repository.owner}/${success.repository.name}`);
    }
  };

  return (
    <Box>
      <Heading size="md" mb={4}>Add Repository by URL</Heading>
      
      <Box as="form" onSubmit={handleSubmit} mb={6}>
        <VStack spacing={4} align="flex-start">
          <FormControl isRequired>
            <FormLabel>GitHub Repository URL</FormLabel>
            <Input
              value={repoUrl}
              onChange={(e) => setRepoUrl(e.target.value)}
              placeholder="https://github.com/owner/repository"
              isDisabled={isLoading}
            />
          </FormControl>
          
          <Button
            type="submit"
            colorScheme="blue"
            isLoading={isLoading}
            loadingText="Ingesting..."
          >
            Ingest Repository
          </Button>
        </VStack>
      </Box>
      
      {logs.length > 0 && (
        <Box mt={4} p={4} borderWidth="1px" borderRadius="md" bg="gray.50" color="gray.800">
          <Heading size="sm" mb={2}>Process Log</Heading>
          <Box maxH="200px" overflowY="auto" fontFamily="mono" fontSize="sm">
            {logs.map((log, index) => (
              <Text key={index}>{log}</Text>
            ))}
            {isLoading && <Spinner size="sm" ml={2} />}
          </Box>
        </Box>
      )}
      
      {error && (
        <Alert status="error" mt={4}>
          <AlertIcon />
          <AlertTitle>Error!</AlertTitle>
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      
      {success && (
        <Box mt={4}>
          <Alert status="success">
            <AlertIcon />
            <AlertTitle>Success!</AlertTitle>
            <AlertDescription>Repository has been added successfully</AlertDescription>
          </Alert>
          
          <Box mt={4} p={4} borderWidth="1px" borderRadius="md">
            <Heading size="sm" mb={2}>Repository Details</Heading>
            <Code p={2} display="block" whiteSpace="pre" borderRadius="md">
              {JSON.stringify(success, null, 2)}
            </Code>
            
            <Divider my={4} />
            
            <Button 
              colorScheme="teal" 
              onClick={handleViewRepository}
            >
              View Repository
            </Button>
          </Box>
        </Box>
      )}
    </Box>
  );
}



================================================
File: client/src/components/Analysis/ExportOptions.tsx
================================================
import {
  Button,
  Checkbox,
  CheckboxGroup,
  FormControl,
  FormLabel,
  HStack,
  Icon,
  Modal,
  ModalBody,
  ModalCloseButton,
  ModalContent,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Radio,
  RadioGroup,
  Stack,
  Text,
  useToast,
} from '@chakra-ui/react';
import { useMutation } from '@tanstack/react-query';
import { useState } from 'react';
import {
  FiDownload,
  FiFile,
  FiFileText,
  FiCode,
} from 'react-icons/fi';
import { apiClient } from '@/lib/api';

interface ExportOptionsProps {
  analysisId: string;
  isOpen: boolean;
  onClose: () => void;
}

interface ExportConfig {
  format: 'pdf' | 'json' | 'html';
  sections: string[];
}

export function ExportOptions({
  analysisId,
  isOpen,
  onClose,
}: ExportOptionsProps) {
  const toast = useToast();
  const [format, setFormat] = useState<ExportConfig['format']>('pdf');
  const [selectedSections, setSelectedSections] = useState<string[]>([
    'overview',
    'insights',
    'vulnerabilities',
  ]);

  const exportMutation = useMutation<Blob, Error, ExportConfig>(
    (config) =>
      apiClient.analysis.export(analysisId, config).then((response) => response.data),
    {
      onSuccess: (data) => {
        // Create a download link
        const url = window.URL.createObjectURL(data);
        const link = document.createElement('a');
        link.href = url;
        link.download = `analysis-${analysisId}.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);

        toast({
          title: 'Export successful',
          description: 'Your analysis has been exported successfully.',
          status: 'success',
          duration: 5000,
        });
        onClose();
      },
      onError: (error) => {
        toast({
          title: 'Export failed',
          description: error.message,
          status: 'error',
          duration: 5000,
        });
      },
    }
  );

  const handleExport = () => {
    const config: ExportConfig = {
      format,
      sections: selectedSections,
    };
    exportMutation.mutate(config);
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="md">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Export Analysis</ModalHeader>
        <ModalCloseButton />

        <ModalBody>
          <Stack spacing={6}>
            <FormControl>
              <FormLabel>Export Format</FormLabel>
              <RadioGroup value={format} onChange={(value: ExportConfig['format']) => setFormat(value)}>
                <Stack>
                  <Radio value="pdf">
                    <HStack>
                      <Icon as={FiFileText} />
                      <Text>PDF Document</Text>
                    </HStack>
                  </Radio>
                  <Radio value="json">
                    <HStack>
                      <Icon as={FiCode} />
                      <Text>JSON Data</Text>
                    </HStack>
                  </Radio>
                  <Radio value="html">
                    <HStack>
                      <Icon as={FiFile} />
                      <Text>HTML Report</Text>
                    </HStack>
                  </Radio>
                </Stack>
              </RadioGroup>
            </FormControl>

            <FormControl>
              <FormLabel>Include Sections</FormLabel>
              <CheckboxGroup
                value={selectedSections}
                onChange={(values: string[]) => setSelectedSections(values)}
              >
                <Stack>
                  <Checkbox value="overview">Overview</Checkbox>
                  <Checkbox value="insights">Code Insights</Checkbox>
                  <Checkbox value="vulnerabilities">
                    Security Vulnerabilities
                  </Checkbox>
                  <Checkbox value="components">Component Analysis</Checkbox>
                </Stack>
              </CheckboxGroup>
            </FormControl>
          </Stack>
        </ModalBody>

        <ModalFooter>
          <Button variant="ghost" mr={3} onClick={onClose}>
            Cancel
          </Button>
          <Button
            leftIcon={<Icon as={FiDownload} />}
            onClick={handleExport}
            isLoading={exportMutation.isLoading}
            loadingText="Exporting..."
          >
            Export
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}



================================================
File: client/src/components/Common/Pagination.tsx
================================================
import {
  Button,
  ButtonGroup,
  HStack,
  Icon,
  Select,
  Text,
} from '@chakra-ui/react';
import { FiChevronLeft, FiChevronRight } from 'react-icons/fi';

interface PaginationProps {
  currentPage: number;
  totalPages: number;
  onPageChange: (page: number) => void;
}

export function Pagination({
  currentPage,
  totalPages,
  onPageChange,
}: PaginationProps) {
  const pages = Array.from({ length: totalPages }, (_, i) => i + 1);

  const handlePageChange = (page: number) => {
    if (page >= 1 && page <= totalPages) {
      onPageChange(page);
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  };

  if (totalPages <= 1) {
    return null;
  }

  return (
    <HStack spacing={4} justify="center">
      <ButtonGroup size="sm" variant="outline" isAttached>
        <Button
          onClick={() => handlePageChange(currentPage - 1)}
          isDisabled={currentPage === 1}
          aria-label="Previous page"
        >
          <Icon as={FiChevronLeft} />
        </Button>

        {totalPages <= 7 ? (
          // Show all pages if total pages are 7 or less
          pages.map((page) => (
            <Button
              key={page}
              onClick={() => handlePageChange(page)}
              variant={currentPage === page ? 'solid' : 'outline'}
              aria-current={currentPage === page ? 'page' : undefined}
            >
              {page}
            </Button>
          ))
        ) : (
          // Show truncated pagination for more than 7 pages
          <>
            {/* First page */}
            <Button
              onClick={() => handlePageChange(1)}
              variant={currentPage === 1 ? 'solid' : 'outline'}
            >
              1
            </Button>

            {/* Ellipsis or second page */}
            {currentPage > 3 && <Text>...</Text>}

            {/* Current page and surrounding pages */}
            {pages
              .filter(
                (page) =>
                  page !== 1 &&
                  page !== totalPages &&
                  Math.abs(currentPage - page) <= 1
              )
              .map((page) => (
                <Button
                  key={page}
                  onClick={() => handlePageChange(page)}
                  variant={currentPage === page ? 'solid' : 'outline'}
                  aria-current={currentPage === page ? 'page' : undefined}
                >
                  {page}
                </Button>
              ))}

            {/* Ellipsis or second-to-last page */}
            {currentPage < totalPages - 2 && <Text>...</Text>}

            {/* Last page */}
            <Button
              onClick={() => handlePageChange(totalPages)}
              variant={currentPage === totalPages ? 'solid' : 'outline'}
            >
              {totalPages}
            </Button>
          </>
        )}

        <Button
          onClick={() => handlePageChange(currentPage + 1)}
          isDisabled={currentPage === totalPages}
          aria-label="Next page"
        >
          <Icon as={FiChevronRight} />
        </Button>
      </ButtonGroup>

      <Select
        value={currentPage}
        onChange={(e) => handlePageChange(Number(e.target.value))}
        w="auto"
        size="sm"
      >
        {pages.map((page) => (
          <option key={page} value={page}>
            Page {page}
          </option>
        ))}
      </Select>
    </HStack>
  );
}



================================================
File: client/src/components/Common/ShareModal.tsx
================================================
import React, { useState } from 'react';
import {
  Button,
  FormControl,
  FormLabel,
  HStack,
  Icon,
  Input,
  Modal,
  ModalBody,
  ModalCloseButton,
  ModalContent,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Stack,
  Switch,
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  Tabs,
  useClipboard,
  useToast,
} from '@chakra-ui/react';
import { useMutation } from '@tanstack/react-query';
import {
  FiCheck,
  FiCopy,
  FiLink,
  FiMail,
} from 'react-icons/fi';
import { apiClient } from '@/lib/api';

interface ShareModalProps {
  resourceId: string;
  resourceType: 'repository' | 'analysis';
  isOpen: boolean;
  onClose: () => void;
}

interface ShareLinkResponse {
  url: string;
  expiresAt?: string;
}

interface ShareConfig {
  email?: string;
  expiresInDays?: number;
  allowEdit: boolean;
}

interface ShareEmailConfig extends ShareConfig {
  email: string;
}

export function ShareModal({
  resourceId,
  resourceType,
  isOpen,
  onClose,
}: ShareModalProps) {
  const toast = useToast();
  const [shareUrl, setShareUrl] = useState('');
  const [email, setEmail] = useState('');
  const [expiresInDays, setExpiresInDays] = useState(7);
  const [allowEdit, setAllowEdit] = useState(false);
  const { onCopy, hasCopied } = useClipboard(shareUrl);

  // Generate share link mutation
  const generateLink = useMutation<ShareLinkResponse, Error, ShareConfig>({
    mutationFn: (config: ShareConfig) =>
      apiClient.share.generateLink(resourceId, resourceType, config),
    onSuccess: (data: ShareLinkResponse) => {
      setShareUrl(data.url);
      toast({
        title: 'Share link generated',
        description: 'Link has been generated successfully.',
        status: 'success',
        duration: 5000,
      });
    },
    onError: (error: Error) => {
      toast({
        title: 'Failed to generate link',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    },
  });

  // Send email invitation mutation
  const sendEmail = useMutation<void, Error, ShareEmailConfig>({
    mutationFn: (config: ShareEmailConfig) =>
      apiClient.share.sendEmail(resourceId, resourceType, config),
    onSuccess: () => {
      toast({
        title: 'Invitation sent',
        description: 'Share invitation has been sent successfully.',
        status: 'success',
        duration: 5000,
      });
      setEmail('');
      onClose();
    },
    onError: (error: Error) => {
      toast({
        title: 'Failed to send invitation',
        description: error.message,
        status: 'error',
        duration: 5000,
      });
    },
  });

  const handleGenerateLink = () => {
    const config: ShareConfig = {
      expiresInDays,
      allowEdit,
    };
    generateLink.mutate(config);
  };

  const handleSendEmail = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!email) {
      toast({
        title: 'Email required',
        description: 'Please enter an email address.',
        status: 'warning',
        duration: 5000,
      });
      return;
    }

    const config: ShareEmailConfig = {
      email,
      expiresInDays,
      allowEdit,
    };
    sendEmail.mutate(config);
  };

  return (
    <Modal isOpen={isOpen} onClose={onClose} size="md">
      <ModalOverlay />
      <ModalContent>
        <ModalHeader>Share {resourceType}</ModalHeader>
        <ModalCloseButton />

        <ModalBody>
          <Tabs>
            <TabList>
              <Tab>Share Link</Tab>
              <Tab>Email Invite</Tab>
            </TabList>

            <TabPanels>
              {/* Share Link Panel */}
              <TabPanel>
                <Stack spacing={6}>
                  <FormControl>
                    <FormLabel>Share Link</FormLabel>
                    <HStack>
                      <Input
                        value={shareUrl}
                        isReadOnly
                        placeholder="Generate a link to share"
                      />
                      {shareUrl && (
                        <Button
                          onClick={onCopy}
                          leftIcon={
                            <Icon as={hasCopied ? FiCheck : FiCopy} />
                          }
                        >
                          {hasCopied ? 'Copied' : 'Copy'}
                        </Button>
                      )}
                    </HStack>
                  </FormControl>

                  <Stack spacing={4}>
                    <FormControl display="flex" alignItems="center">
                      <FormLabel mb={0}>Allow Edit Access</FormLabel>
                      <Switch
                        isChecked={allowEdit}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                          setAllowEdit(e.target.checked)
                        }
                      />
                    </FormControl>

                    <FormControl>
                      <FormLabel>Expires In (Days)</FormLabel>
                      <Input
                        type="number"
                        value={expiresInDays}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                          setExpiresInDays(parseInt(e.target.value, 10))
                        }
                        min={1}
                        max={30}
                      />
                    </FormControl>
                  </Stack>

                  <Button
                    leftIcon={<Icon as={FiLink} />}
                    onClick={handleGenerateLink}
                    isLoading={generateLink.isLoading}
                    loadingText="Generating..."
                  >
                    Generate Link
                  </Button>
                </Stack>
              </TabPanel>

              {/* Email Invite Panel */}
              <TabPanel>
                <form onSubmit={handleSendEmail}>
                  <Stack spacing={6}>
                    <FormControl>
                      <FormLabel>Email Address</FormLabel>
                      <Input
                        type="email"
                        value={email}
                        onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                          setEmail(e.target.value)
                        }
                        placeholder="Enter email address"
                      />
                    </FormControl>

                    <Stack spacing={4}>
                      <FormControl display="flex" alignItems="center">
                        <FormLabel mb={0}>Allow Edit Access</FormLabel>
                        <Switch
                          isChecked={allowEdit}
                          onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                            setAllowEdit(e.target.checked)
                          }
                        />
                      </FormControl>

                      <FormControl>
                        <FormLabel>Expires In (Days)</FormLabel>
                        <Input
                          type="number"
                          value={expiresInDays}
                          onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                            setExpiresInDays(parseInt(e.target.value, 10))
                          }
                          min={1}
                          max={30}
                        />
                      </FormControl>
                    </Stack>

                    <Button
                      type="submit"
                      leftIcon={<Icon as={FiMail} />}
                      isLoading={sendEmail.isLoading}
                      loadingText="Sending..."
                    >
                      Send Invitation
                    </Button>
                  </Stack>
                </form>
              </TabPanel>
            </TabPanels>
          </Tabs>
        </ModalBody>

        <ModalFooter>
          <Button variant="ghost" onClick={onClose}>
            Close
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}



================================================
File: client/src/components/Dashboard/DashboardChart.tsx
================================================
import { useToken } from '@chakra-ui/react';
import {
  Area,
  AreaChart,
  CartesianGrid,
  ResponsiveContainer,
  Tooltip,
  XAxis,
  YAxis,
} from 'recharts';

interface Analysis {
  createdAt: string;
  status: string;
  insights: Array<{ type: string }>;
  vulnerabilities: Array<{ severity: string }>;
}

interface DashboardChartProps {
  data: Analysis[];
}

export function DashboardChart({ data }: DashboardChartProps) {
  const [brand500, brand200] = useToken('colors', ['brand.500', 'brand.200']);

  // Process data for chart
  const chartData = data.reduce((acc: any[], analysis) => {
    const date = new Date(analysis.createdAt);
    const formattedDate = date.toLocaleDateString();
    
    const existingEntry = acc.find((entry) => entry.date === formattedDate);
    
    if (existingEntry) {
      existingEntry.analyses += 1;
      existingEntry.insights += analysis.insights?.length || 0;
      existingEntry.vulnerabilities += analysis.vulnerabilities?.length || 0;
    } else {
      acc.push({
        date: formattedDate,
        analyses: 1,
        insights: analysis.insights?.length || 0,
        vulnerabilities: analysis.vulnerabilities?.length || 0,
      });
    }
    
    return acc;
  }, []);

  return (
    <ResponsiveContainer width="100%" height="100%">
      <AreaChart
        data={chartData}
        margin={{ top: 10, right: 30, left: 0, bottom: 0 }}
      >
        <defs>
          <linearGradient id="colorAnalyses" x1="0" y1="0" x2="0" y2="1">
            <stop offset="5%" stopColor={brand500} stopOpacity={0.8} />
            <stop offset="95%" stopColor={brand500} stopOpacity={0} />
          </linearGradient>
          <linearGradient id="colorInsights" x1="0" y1="0" x2="0" y2="1">
            <stop offset="5%" stopColor={brand200} stopOpacity={0.8} />
            <stop offset="95%" stopColor={brand200} stopOpacity={0} />
          </linearGradient>
        </defs>
        <CartesianGrid strokeDasharray="3 3" />
        <XAxis
          dataKey="date"
          tick={{ fontSize: 12 }}
        />
        <YAxis tick={{ fontSize: 12 }} />
        <Tooltip />
        <Area
          type="monotone"
          dataKey="analyses"
          stroke={brand500}
          fillOpacity={1}
          fill="url(#colorAnalyses)"
        />
        <Area
          type="monotone"
          dataKey="insights"
          stroke={brand200}
          fillOpacity={1}
          fill="url(#colorInsights)"
        />
      </AreaChart>
    </ResponsiveContainer>
  );
}



================================================
File: client/src/components/Dashboard/RecentAnalysesList.tsx
================================================
import {
  Badge,
  Box,
  Icon,
  Link,
  Skeleton,
  Stack,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';
import { FiAlertCircle, FiCheck, FiClock, FiXCircle } from 'react-icons/fi';
import { Link as RouterLink } from 'react-router-dom';

interface Analysis {
  id: string;
  repositoryId: string;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: string;
  insights: Array<{ type: string }>;
  vulnerabilities: Array<{ severity: string }>;
}

interface RecentAnalysesListProps {
  analyses: Analysis[];
  isLoading: boolean;
}

export function RecentAnalysesList({ analyses, isLoading }: RecentAnalysesListProps) {
  const hoverBg = useColorModeValue('gray.50', 'gray.700');

  if (isLoading) {
    return (
      <Stack spacing={4}>
        {[...Array(5)].map((_, i) => (
          <Skeleton key={i} height="60px" rounded="md" />
        ))}
      </Stack>
    );
  }

  if (!analyses.length) {
    return (
      <Stack align="center" spacing={4} py={8}>
        <Icon as={FiClock} boxSize={10} color="gray.400" />
        <Text color="gray.500">No analyses yet</Text>
      </Stack>
    );
  }

  return (
    <Stack spacing={2}>
      {analyses.map((analysis) => (
        <Link
          key={analysis.id}
          as={RouterLink}
          to={`/analyses/${analysis.id}`}
          _hover={{ textDecoration: 'none' }}
        >
          <Box
            p={4}
            rounded="md"
            _hover={{ bg: hoverBg }}
            transition="background-color 0.2s"
          >
            <Stack spacing={2}>
              <Stack direction="row" justify="space-between" align="center">
                <Badge
                  colorScheme={
                    analysis.status === 'completed'
                      ? 'green'
                      : analysis.status === 'failed'
                      ? 'red'
                      : analysis.status === 'processing'
                      ? 'blue'
                      : 'yellow'
                  }
                  display="flex"
                  alignItems="center"
                >
                  <Icon
                    as={
                      analysis.status === 'completed'
                        ? FiCheck
                        : analysis.status === 'failed'
                        ? FiXCircle
                        : analysis.status === 'processing'
                        ? FiClock
                        : FiAlertCircle
                    }
                    mr={1}
                  />
                  {analysis.status.charAt(0).toUpperCase() + analysis.status.slice(1)}
                </Badge>
                <Text fontSize="sm" color="gray.500">
                  {new Date(analysis.createdAt).toLocaleDateString()}
                </Text>
              </Stack>

              <Stack direction="row" spacing={4}>
                <Text fontSize="sm">
                  Insights: {analysis.insights?.length || 0}
                </Text>
                <Text fontSize="sm" color="red.500">
                  Vulnerabilities: {analysis.vulnerabilities?.length || 0}
                </Text>
              </Stack>
            </Stack>
          </Box>
        </Link>
      ))}
    </Stack>
  );
}



================================================
File: client/src/components/ErrorBoundary/ErrorBoundary.tsx
================================================
import {
  Button,
  Container,
  Heading,
  Icon,
  Stack,
  Text,
} from '@chakra-ui/react';
import React from 'react';
import { FiAlertTriangle, FiRefreshCw } from 'react-icons/fi';

interface Props {
  children: React.ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
    };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log the error to an error reporting service
    console.error('Error caught by ErrorBoundary:', error, errorInfo);
  }

  handleRetry = () => {
    window.location.reload();
  };

  render() {
    if (this.state.hasError) {
      return (
        <Container maxW="container.md" py={16}>
          <Stack spacing={8} align="center" textAlign="center">
            <Icon as={FiAlertTriangle} boxSize={12} color="red.500" />
            <Stack spacing={4}>
              <Heading size="xl">Something went wrong</Heading>
              <Text color="gray.500">
                An unexpected error occurred. Our team has been notified.
              </Text>
              {this.state.error && (
                <Text
                  color="gray.500"
                  fontSize="sm"
                  fontFamily="monospace"
                  whiteSpace="pre-wrap"
                >
                  {this.state.error.toString()}
                </Text>
              )}
            </Stack>
            <Button
              leftIcon={<Icon as={FiRefreshCw} />}
              onClick={this.handleRetry}
              colorScheme="brand"
            >
              Retry
            </Button>
          </Stack>
        </Container>
      );
    }

    return this.props.children;
  }
}



================================================
File: client/src/components/Layout/Layout.tsx
================================================
import { Box, Container, Flex } from '@chakra-ui/react';
import { Navbar } from './Navbar';
import { Sidebar } from './Sidebar';
import { useAuth } from '@/contexts/AuthContext';

interface LayoutProps {
  children: React.ReactNode;
}

export function Layout({ children }: LayoutProps) {
  const { user } = useAuth();

  if (!user) {
    return (
      <Box minH="100vh">
        <Navbar />
        <Container maxW="container.xl" py={8}>
          {children}
        </Container>
      </Box>
    );
  }

  return (
    <Box minH="100vh">
      <Navbar />
      <Flex>
        <Sidebar />
        <Box flex="1" p={8}>
          {children}
        </Box>
      </Flex>
    </Box>
  );
}



================================================
File: client/src/components/Layout/Navbar.tsx
================================================
import {
  Box,
  Button,
  Flex,
  HStack,
  IconButton,
  Image,
  Menu,
  MenuButton,
  MenuItem,
  MenuList,
  useColorMode,
  useColorModeValue,
} from '@chakra-ui/react';
import { FiGithub, FiMoon, FiSun, FiUser } from 'react-icons/fi';
import { Link } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';

export function Navbar() {
  const { user, login, logout } = useAuth();
  const { colorMode, toggleColorMode } = useColorMode();
  const bg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  return (
    <Box
      as="nav"
      position="sticky"
      top={0}
      zIndex="sticky"
      bg={bg}
      borderBottom="1px"
      borderColor={borderColor}
    >
      <Flex
        h={16}
        alignItems="center"
        justifyContent="space-between"
        maxW="container.xl"
        mx="auto"
        px={4}
      >
        <Link to="/">
          <HStack spacing={2}>
            <Image
              src="/logo.svg"
              alt="CodeInsight"
              boxSize={8}
            />
            <Box
              as="span"
              fontSize="xl"
              fontWeight="bold"
              display={{ base: 'none', md: 'block' }}
            >
              CodeInsight
            </Box>
          </HStack>
        </Link>

        <HStack spacing={4}>
          <IconButton
            aria-label="Toggle color mode"
            icon={colorMode === 'light' ? <FiMoon /> : <FiSun />}
            onClick={toggleColorMode}
            variant="ghost"
          />

          {user ? (
            <Menu>
              <MenuButton
                as={Button}
                rightIcon={<FiUser />}
                variant="ghost"
              >
                {user.name}
              </MenuButton>
              <MenuList>
                <MenuItem as={Link} to="/profile">
                  Profile
                </MenuItem>
                <MenuItem onClick={logout}>
                  Logout
                </MenuItem>
              </MenuList>
            </Menu>
          ) : (
            <Button
              leftIcon={<FiGithub />}
              onClick={login}
            >
              Login with GitHub
            </Button>
          )}
        </HStack>
      </Flex>
    </Box>
  );
}



================================================
File: client/src/components/Layout/Sidebar.tsx
================================================
import {
  Box,
  Button,
  Icon,
  Stack,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';
import {
  FiBook,
  FiDatabase,
  FiHome,
  FiLayers,
  FiShield,
} from 'react-icons/fi';
import { Link, useLocation } from 'react-router-dom';

interface NavItem {
  label: string;
  icon: typeof FiHome;
  path: string;
}

const NAV_ITEMS: NavItem[] = [
  { label: 'Dashboard', icon: FiHome, path: '/dashboard' },
  { label: 'Repositories', icon: FiDatabase, path: '/repositories' },
  { label: 'Analyses', icon: FiLayers, path: '/analyses' },
  { label: 'Security', icon: FiShield, path: '/security' },
  { label: 'Documentation', icon: FiBook, path: '/docs' },
];

export function Sidebar() {
  const location = useLocation();
  const bg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  return (
    <Box
      as="nav"
      pos="sticky"
      top="16"
      h="calc(100vh - 4rem)"
      w="64"
      bg={bg}
      borderRight="1px"
      borderColor={borderColor}
      py={8}
      px={4}
      overflowY="auto"
    >
      <Stack spacing={2}>
        {NAV_ITEMS.map((item) => (
          <Button
            key={item.path}
            as={Link}
            to={item.path}
            variant={location.pathname === item.path ? 'solid' : 'ghost'}
            justifyContent="flex-start"
            leftIcon={<Icon as={item.icon} boxSize={5} />}
            size="lg"
            width="full"
          >
            <Text>{item.label}</Text>
          </Button>
        ))}
      </Stack>
    </Box>
  );
}



================================================
File: client/src/components/Repository/AddRepositoryModal.tsx
================================================
import {
  Button,
  FormControl,
  FormErrorMessage,
  FormLabel,
  Input,
  Modal,
  ModalBody,
  ModalCloseButton,
  ModalContent,
  ModalFooter,
  ModalHeader,
  ModalOverlay,
  Stack,
  Text,
  useToast,
} from '@chakra-ui/react';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useState } from 'react';
import { apiClient } from '@/lib/api';

interface AddRepositoryModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export function AddRepositoryModal({ isOpen, onClose }: AddRepositoryModalProps) {
  const [owner, setOwner] = useState('');
  const [name, setName] = useState('');
  const [error, setError] = useState<string | null>(null);
  const queryClient = useQueryClient();
  const toast = useToast();

  // Add repository mutation
  const addRepository = useMutation(
    () => apiClient.repositories.add(owner, name),
    {
      onSuccess: () => {
        // Invalidate and refetch
        queryClient.invalidateQueries(['repositories']);
        
        // Show success message
        toast({
          title: 'Repository added',
          description: 'The repository has been added successfully.',
          status: 'success',
          duration: 5000,
          isClosable: true,
        });

        // Reset form and close modal
        handleClose();
      },
      onError: (error: any) => {
        setError(error.message || 'Failed to add repository');
        
        toast({
          title: 'Error',
          description: error.message || 'Failed to add repository',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
      },
    }
  );

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!owner || !name) {
      setError('Please fill in all fields');
      return;
    }

    addRepository.mutate();
  };

  const handleClose = () => {
    setOwner('');
    setName('');
    setError(null);
    onClose();
  };

  return (
    <Modal isOpen={isOpen} onClose={handleClose} size="md">
      <ModalOverlay />
      <ModalContent as="form" onSubmit={handleSubmit}>
        <ModalHeader>Add Repository</ModalHeader>
        <ModalCloseButton />

        <ModalBody>
          <Stack spacing={4}>
            <Text color="gray.500" fontSize="sm">
              Enter the GitHub repository details to add it for analysis.
            </Text>

            <FormControl isInvalid={!!error}>
              <FormLabel>Repository Owner</FormLabel>
              <Input
                placeholder="e.g., facebook"
                value={owner}
                onChange={(e) => setOwner(e.target.value)}
              />
            </FormControl>

            <FormControl isInvalid={!!error}>
              <FormLabel>Repository Name</FormLabel>
              <Input
                placeholder="e.g., react"
                value={name}
                onChange={(e) => setName(e.target.value)}
              />
              {error && <FormErrorMessage>{error}</FormErrorMessage>}
            </FormControl>
          </Stack>
        </ModalBody>

        <ModalFooter>
          <Button variant="ghost" mr={3} onClick={handleClose}>
            Cancel
          </Button>
          <Button
            type="submit"
            isLoading={addRepository.isLoading}
            loadingText="Adding..."
          >
            Add Repository
          </Button>
        </ModalFooter>
      </ModalContent>
    </Modal>
  );
}



================================================
File: client/src/components/Repository/FileTreeNavigator.tsx
================================================
import {
  Box,
  Button,
  HStack,
  Icon,
  Input,
  InputGroup,
  InputLeftElement,
  Spinner,
  Stack,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';
import { useQuery } from '@tanstack/react-query';
import React, { useState } from 'react';
import {
  FiChevronDown,
  FiChevronRight,
  FiFile,
  FiFolder,
  FiSearch,
} from 'react-icons/fi';
import { apiClient } from '@/lib/api';

interface FileTreeNode {
  name: string;
  type: 'file' | 'directory';
  path: string;
  children?: FileTreeNode[];
  size?: number;
}

interface FileTreeNodeProps {
  node: FileTreeNode;
  level: number;
  onSelect: (node: FileTreeNode) => void;
  selectedPath?: string;
}

interface FileTreeNavigatorProps {
  repositoryId: string;
  onFileSelect?: (path: string | null) => void;
  selectedPath?: string;
}

function FileTreeNodeComponent({
  node,
  level,
  onSelect,
  selectedPath,
}: FileTreeNodeProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const bg = useColorModeValue('gray.50', 'gray.700');
  const borderColor = useColorModeValue('gray.200', 'gray.600');
  const hoverBg = useColorModeValue('gray.100', 'gray.600');
  const isSelected = node.path === selectedPath;

  const handleClick = (e: React.MouseEvent) => {
    e.stopPropagation();
    if (node.type === 'directory') {
      setIsExpanded(!isExpanded);
    } else {
      onSelect(node);
    }
  };

  const formatSize = (size: number) => {
    if (size < 1024) return `${size} B`;
    if (size < 1024 * 1024) return `${(size / 1024).toFixed(1)} KB`;
    return `${(size / (1024 * 1024)).toFixed(1)} MB`;
  };

  return (
    <Stack spacing={0}>
      <HStack
        py={2}
        px={4}
        spacing={2}
        cursor="pointer"
        onClick={handleClick}
        bg={isSelected ? bg : 'transparent'}
        _hover={{ bg: hoverBg }}
        borderRadius="md"
      >
        <Box pl={`${level * 20}px`}>
          {node.type === 'directory' ? (
            <Icon
              as={isExpanded ? FiChevronDown : FiChevronRight}
              color="gray.500"
            />
          ) : (
            <Box w="16px" />
          )}
        </Box>
        <Icon
          as={node.type === 'directory' ? FiFolder : FiFile}
          color={node.type === 'directory' ? 'yellow.400' : 'blue.400'}
        />
        <Text flex="1" fontSize="sm">
          {node.name}
        </Text>
        {node.size && (
          <Text fontSize="xs" color="gray.500">
            {formatSize(node.size)}
          </Text>
        )}
      </HStack>
      {isExpanded && node.children && (
        <Stack spacing={0}>
          {node.children.map((child) => (
            <FileTreeNodeComponent
              key={child.path}
              node={child}
              level={level + 1}
              onSelect={onSelect}
              selectedPath={selectedPath}
            />
          ))}
        </Stack>
      )}
    </Stack>
  );
}

export function FileTreeNavigator({
  repositoryId,
  onFileSelect,
  selectedPath,
}: FileTreeNavigatorProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  const { data: fileTree, isLoading } = useQuery(
    ['repository', repositoryId, 'files'],
    () => apiClient.repositories.getFileTree(repositoryId),
    {
      select: (response) => response.data,
    }
  );

  const filterTree = (
    node: FileTreeNode,
    query: string
  ): FileTreeNode | null => {
    if (node.name.toLowerCase().includes(query.toLowerCase())) {
      return node;
    }

    if (node.children) {
      const filteredChildren = node.children
        .map((child) => filterTree(child, query))
        .filter((child): child is FileTreeNode => child !== null);

      if (filteredChildren.length > 0) {
        return {
          ...node,
          children: filteredChildren,
        };
      }
    }

    return null;
  };

  const filteredTree = searchQuery && fileTree
    ? filterTree(fileTree, searchQuery)
    : fileTree;

  const handleSelect = (node: FileTreeNode) => {
    if (node.type === 'file') {
      onFileSelect?.(node.path);
    }
  };

  if (isLoading) {
    return (
      <Stack align="center" justify="center" h="200px">
        <Spinner />
      </Stack>
    );
  }

  return (
    <Stack
      spacing={4}
      borderWidth="1px"
      borderColor={borderColor}
      borderRadius="lg"
      p={4}
    >
      <InputGroup size="sm">
        <InputLeftElement>
          <Icon as={FiSearch} color="gray.500" />
        </InputLeftElement>
        <Input
          placeholder="Search files..."
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
        />
      </InputGroup>

      <Box overflowY="auto" maxH="500px">
        {filteredTree ? (
          <FileTreeNodeComponent
            node={filteredTree}
            level={0}
            onSelect={handleSelect}
            selectedPath={selectedPath}
          />
        ) : (
          <Stack align="center" justify="center" h="200px" spacing={4}>
            <Text color="gray.500">No files found</Text>
            {searchQuery && (
              <Button
                size="sm"
                variant="ghost"
                onClick={() => setSearchQuery('')}
              >
                Clear Search
              </Button>
            )}
          </Stack>
        )}
      </Box>
    </Stack>
  );
}



================================================
File: client/src/components/Repository/RepositoryCard.tsx
================================================
import {
  Badge,
  Box,
  Button,
  HStack,
  Icon,
  Stack,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';
import { FiGitBranch, FiGithub, FiSearch } from 'react-icons/fi';
import { Link as RouterLink } from 'react-router-dom';
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { apiClient } from '@/lib/api';

interface Repository {
  id: string;
  name: string;
  owner: string;
  description: string;
  private: boolean;
  lastAnalysis?: {
    id: string;
    status: string;
    createdAt: string;
  };
}

interface RepositoryCardProps {
  repository: Repository;
}

export function RepositoryCard({ repository }: RepositoryCardProps) {
  const queryClient = useQueryClient();
  const cardBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  // Start analysis mutation
  const startAnalysis = useMutation(
    () => apiClient.analysis.start(repository.id),
    {
      onSuccess: () => {
        // Invalidate queries to refresh data
        queryClient.invalidateQueries(['repositories']);
        queryClient.invalidateQueries(['analyses']);
      },
    }
  );

  return (
    <Box
      bg={cardBg}
      border="1px"
      borderColor={borderColor}
      rounded="lg"
      overflow="hidden"
      transition="all 0.2s"
      _hover={{
        transform: 'translateY(-2px)',
        shadow: 'md',
      }}
    >
      <Stack spacing={4} p={4}>
        <Stack spacing={2}>
          <HStack justify="space-between">
            <Text
              as={RouterLink}
              to={`/repositories/${repository.id}`}
              fontWeight="semibold"
              _hover={{ color: 'brand.500' }}
            >
              {repository.name}
            </Text>
            <Badge
              colorScheme={repository.private ? 'red' : 'green'}
              variant="subtle"
            >
              {repository.private ? 'Private' : 'Public'}
            </Badge>
          </HStack>

          <Text
            fontSize="sm"
            color="gray.500"
            noOfLines={2}
          >
            {repository.description || 'No description provided'}
          </Text>
        </Stack>

        <Stack spacing={3}>
          <HStack fontSize="sm">
            <Icon as={FiGithub} />
            <Text>{repository.owner}</Text>
          </HStack>

          {repository.lastAnalysis && (
            <HStack fontSize="sm">
              <Icon as={FiGitBranch} />
              <Text>
                Last analyzed:{' '}
                {new Date(repository.lastAnalysis.createdAt).toLocaleDateString()}
              </Text>
              <Badge colorScheme={
                repository.lastAnalysis.status === 'completed'
                  ? 'green'
                  : repository.lastAnalysis.status === 'failed'
                  ? 'red'
                  : 'yellow'
              }>
                {repository.lastAnalysis.status}
              </Badge>
            </HStack>
          )}
        </Stack>

        <Stack direction="row" spacing={2}>
          <Button
            as={RouterLink}
            to={`/repositories/${repository.id}`}
            variant="ghost"
            size="sm"
            leftIcon={<Icon as={FiGitBranch} />}
            flex={1}
          >
            View
          </Button>
          <Button
            size="sm"
            leftIcon={<Icon as={FiSearch} />}
            isLoading={startAnalysis.isLoading}
            onClick={() => startAnalysis.mutate()}
            flex={1}
          >
            Analyze
          </Button>
        </Stack>
      </Stack>
    </Box>
  );
}



================================================
File: client/src/contexts/AuthContext.tsx
================================================
import { createContext, useContext, useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useToast } from '@chakra-ui/react';

interface User {
  id: string;
  login: string;
  name: string;
  email: string;
  avatarUrl: string;
}

interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}

interface AuthContextType {
  user: User | null;
  error: string | null;
  isLoading: boolean;
  isAuthenticated: boolean;
  login: () => void;
  logout: () => void;
  handleAuthCallback: (token: string) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export function AuthProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<AuthState>({
    user: null,
    isLoading: true,
    error: null,
  });
  const navigate = useNavigate();
  const toast = useToast();

  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      // Clear any mock auth settings that might be stored
      localStorage.removeItem('useMockAuth');
      
      const token = localStorage.getItem('token');
      
      if (!token) {
        setState(prev => ({ ...prev, isLoading: false }));
        return;
      }

      // Only attempt API call if we have a token
      try {
        const response = await fetch('http://localhost:3030/api/auth/profile', {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (!response.ok) {
          throw new Error('Authentication failed');
        }

        const data = await response.json();
        setState(prev => ({
          ...prev,
          user: data.data,
          error: null,
          isLoading: false,
        }));
      } catch (error) {
        console.error('Authentication check failed:', error);
        localStorage.removeItem('token');
        setState(prev => ({
          ...prev,
          user: null,
          error: null,
          isLoading: false,
        }));
      }
    } catch (error) {
      console.error('Auth check failed:', error);
      setState(prev => ({
        ...prev,
        user: null,
        error: 'Authentication failed',
        isLoading: false,
      }));
      localStorage.removeItem('token');
      toast({
        title: 'Authentication Error',
        description: 'Please log in again',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  const login = () => {
    // For real GitHub OAuth flow
    window.location.href = 'http://localhost:3030/api/auth/github';
  };

  const logout = async () => {
    try {
      localStorage.removeItem('token');
      localStorage.removeItem('useMockAuth');
      setState(prev => ({
        ...prev,
        user: null,
        error: null,
      }));
      navigate('/login');
      toast({
        title: 'Logged out successfully',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });
    } catch (error) {
      console.error('Logout failed:', error);
      toast({
        title: 'Logout Error',
        description: 'Failed to log out properly',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    }
  };

  const handleAuthCallback = async (token: string) => {
    try {
      localStorage.setItem('token', token);
      
      const response = await fetch('http://localhost:3030/api/auth/profile', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      
      if (!response.ok) {
        throw new Error('Failed to get user profile');
      }
      
      const data = await response.json();
      setState(prev => ({
        ...prev,
        user: data.data,
        error: null,
        isLoading: false,
      }));
      
      return;
    } catch (error) {
      console.error('Error in auth callback:', error);
      localStorage.removeItem('token');
      throw error;
    }
  };

  return (
    <AuthContext.Provider 
      value={{ 
        ...state,
        isAuthenticated: !!state.user,
        login, 
        logout,
        handleAuthCallback
      }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}



================================================
File: client/src/lib/api.ts
================================================
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';
import axios from 'axios';
import { Analysis, AnalysisResponse } from '../types/analysis';

interface ApiResponse<T> {
  data: T;
  message?: string;
}

interface PaginatedResponse<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
}

interface ApiErrorResponse {
  message: string;
  code: string;
}

class ApiException extends Error {
  constructor(
    message: string,
    public code: string
  ) {
    super(message);
    this.name = 'ApiException';
  }
}

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    const API_URL = window.env?.REACT_APP_API_URL || '/api';
    
    this.client = axios.create({
      baseURL: API_URL,
      headers: {
        'Content-Type': 'application/json',
      },
      withCredentials: true,
    }) as AxiosInstance;

    // Add request interceptor for auth token
    (this.client as any).interceptors.request.use((config: AxiosRequestConfig): AxiosRequestConfig => {
      const token = localStorage.getItem('token');
      if (token && config.headers) {
        config.headers.Authorization = `Bearer ${token}`;
      }
      return config;
    });

    // Add response interceptor for error handling
    (this.client as any).interceptors.response.use(
      (response: AxiosResponse): AxiosResponse => response,
      (error: AxiosError) => {
        const status = error.response?.status ?? 500;
        const errorData = error.response?.data as Partial<ApiErrorResponse>;

        if (errorData?.message) {
          throw new ApiException(
            errorData.message,
            errorData.code ?? String(status)
          );
        }

        throw new ApiException(
          'An unexpected error occurred',
          String(status)
        );
      }
    );
  }

  // Analysis endpoints
  analysis = {
    list: async (page = 1, limit = 10): Promise<AnalysisResponse> => {
      const response = await this.client.get<ApiResponse<AnalysisResponse>>(
        `/analyses?page=${page}&limit=${limit}`
      );
      return response.data.data;
    },

    get: async (id: string): Promise<Analysis> => {
      const response = await this.client.get<ApiResponse<Analysis>>(`/analyses/${id}`);
      return response.data.data;
    },

    create: async (repositoryId: string): Promise<Analysis> => {
      const response = await this.client.post<ApiResponse<Analysis>>('/analyses', {
        repositoryId,
      });
      return response.data.data;
    },

    delete: async (id: string): Promise<void> => {
      await this.client.delete(`/analyses/${id}`);
    },
  };

  // Repository endpoints
  repositories = {
    list: async (page = 1, limit = 10) => {
      const response = await this.client.get(`/repositories?page=${page}&limit=${limit}`);
      return response.data.data;
    },

    get: async (id: string) => {
      const response = await this.client.get(`/repositories/${id}`);
      return response.data.data;
    },

    create: async (data: { owner: string; name: string }) => {
      const response = await this.client.post('/repositories', data);
      return response.data.data;
    },

    delete: async (id: string) => {
      await this.client.delete(`/repositories/${id}`);
    },
  };

  // Auth endpoints
  auth = {
    login: async (code: string) => {
      const response = await this.client.post('/auth/github/callback', { code });
      const { token } = response.data.data;
      localStorage.setItem('token', token);
      return token;
    },

    logout: () => {
      localStorage.removeItem('token');
    },

    getProfile: async () => {
      const response = await this.client.get('/auth/profile');
      return response.data.data;
    },
  };
}

export const apiClient = new ApiClient();



================================================
File: client/src/lib/__tests__/api.test.ts
================================================
import { apiClient, ApiException } from '../api';
import axios, { AxiosInstance } from 'axios';

// Import Jest types
import { describe, expect, it, jest, beforeEach } from '@jest/globals';

jest.mock('axios');

// Create a mock type for the axios instance
type MockAxiosInstance = {
  create: jest.MockedFunction<typeof axios.create>;
  get: jest.MockedFunction<any>;
  post: jest.MockedFunction<any>;
} & Partial<AxiosInstance>;

const mockedAxios = axios as unknown as MockAxiosInstance;

describe('API Client', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe('repositories', () => {
    it('should list repositories successfully', async () => {
      const mockRepositories = [
        {
          id: '1',
          owner: 'test-owner',
          name: 'test-repo',
          url: 'https://github.com/test-owner/test-repo',
          createdAt: '2025-03-14T16:37:41Z',
          updatedAt: '2025-03-14T16:37:41Z',
        },
      ];

      mockedAxios.create.mockReturnValue({
        get: jest.fn().mockResolvedValue({ data: mockRepositories }),
      } as any);

      const response = await apiClient.repositories.list();
      expect(response.data).toEqual(mockRepositories);
    });

    it('should handle API errors correctly', async () => {
      const errorResponse = {
        response: {
          data: {
            message: 'Not found',
            code: 'REPOSITORY_NOT_FOUND',
          },
          status: 404,
        },
      };

      mockedAxios.create.mockReturnValue({
        get: jest.fn().mockRejectedValue(errorResponse),
      } as any);

      await expect(apiClient.repositories.get('non-existent')).rejects.toThrow(
        new ApiException('Not found', 'REPOSITORY_NOT_FOUND')
      );
    });
  });

  describe('analysis', () => {
    it('should start analysis successfully', async () => {
      const mockAnalysis = {
        id: '1',
        repositoryId: 'repo-1',
        status: 'pending',
        insights: {},
        vulnerabilities: {},
        createdAt: '2025-03-14T16:37:41Z',
        updatedAt: '2025-03-14T16:37:41Z',
      };

      mockedAxios.create.mockReturnValue({
        post: jest.fn().mockResolvedValue({ data: mockAnalysis }),
      } as any);

      const response = await apiClient.analysis.start('repo-1');
      expect(response.data).toEqual(mockAnalysis);
    });
  });

  describe('share', () => {
    it('should generate share link successfully', async () => {
      const mockShareLink = {
        url: 'https://codeinsight.app/share/abc123',
        expiresAt: '2025-03-21T16:37:41Z',
      };

      mockedAxios.create.mockReturnValue({
        post: jest.fn().mockResolvedValue({ data: mockShareLink }),
      } as any);

      const response = await apiClient.share.generateLink('repo-1', 'repository', {
        expiresInDays: 7,
        allowEdit: false,
      });
      expect(response.data).toEqual(mockShareLink);
    });
  });
});



================================================
File: client/src/pages/AnalysesPage.tsx
================================================
import {
  Badge,
  Box,
  Button,
  Grid,
  Heading,
  HStack,
  Icon,
  Input,
  InputGroup,
  InputLeftElement,
  Select,
  Stack,
  Table,
  Tbody,
  Td,
  Text,
  Th,
  Thead,
  Tr,
  useColorModeValue,
} from '@chakra-ui/react';
import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import { FiAlertCircle, FiCheck, FiClock, FiSearch, FiXCircle } from 'react-icons/fi';
import { Link as RouterLink } from 'react-router-dom';
import { apiClient } from '@/lib/api';
import { Pagination } from '@/components/Common/Pagination';

const ITEMS_PER_PAGE = 10;

interface Analysis {
  id: string;
  repositoryId: string;
  repository: {
    name: string;
    owner: string;
  };
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: string;
  insights: Array<{
    type: string;
    severity: string;
    message: string;
  }>;
  vulnerabilities: Array<{
    severity: string;
    title: string;
    description: string;
  }>;
}

export function AnalysesPage() {
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');
  const [status, setStatus] = useState('all');
  const tableBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  // Fetch analyses with filters and pagination
  const {
    data,
    isLoading,
    error,
  } = useQuery(
    ['analyses', page, status],
    () => apiClient.analysis.list(page, ITEMS_PER_PAGE),
    {
      select: (response) => response.data,
      keepPreviousData: true,
    }
  );

  // Filter and process analyses
  const analyses = data?.analyses || [];
  const filteredAnalyses = analyses
    .filter((analysis: Analysis) => {
      if (status !== 'all' && analysis.status !== status) {
        return false;
      }
      
      const searchTerm = search.toLowerCase();
      return (
        analysis.repository.name.toLowerCase().includes(searchTerm) ||
        analysis.repository.owner.toLowerCase().includes(searchTerm)
      );
    });

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'completed':
        return <Icon as={FiCheck} color="green.500" />;
      case 'failed':
        return <Icon as={FiXCircle} color="red.500" />;
      case 'processing':
        return <Icon as={FiClock} color="blue.500" />;
      default:
        return <Icon as={FiClock} color="yellow.500" />;
    }
  };

  const getSeverityColor = (severity: string) => {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 'red';
      case 'high':
        return 'orange';
      case 'medium':
        return 'yellow';
      case 'low':
        return 'green';
      default:
        return 'gray';
    }
  };

  if (error) {
    return (
      <Stack spacing={4} align="center" justify="center" h="full" py={16}>
        <Icon as={FiAlertCircle} boxSize={10} color="red.500" />
        <Text>Failed to load analyses</Text>
        <Button onClick={() => window.location.reload()}>
          Retry
        </Button>
      </Stack>
    );
  }

  return (
    <Stack spacing={8}>
      <Grid
        templateColumns={{ base: '1fr', md: '1fr auto' }}
        gap={4}
        alignItems="flex-start"
      >
        <Stack spacing={1}>
          <Heading size="lg">Code Analyses</Heading>
          <Text color="gray.500">
            View and manage your repository analyses
          </Text>
        </Stack>
      </Grid>

      <HStack spacing={4}>
        <InputGroup maxW={{ base: 'full', md: '320px' }}>
          <InputLeftElement>
            <Icon as={FiSearch} color="gray.400" />
          </InputLeftElement>
          <Input
            placeholder="Search analyses..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </InputGroup>

        <Select
          value={status}
          onChange={(e) => setStatus(e.target.value)}
          w={{ base: 'full', md: '200px' }}
        >
          <option value="all">All Status</option>
          <option value="completed">Completed</option>
          <option value="processing">Processing</option>
          <option value="pending">Pending</option>
          <option value="failed">Failed</option>
        </Select>
      </HStack>

      <Box
        bg={tableBg}
        rounded="lg"
        shadow="sm"
        borderWidth="1px"
        borderColor={borderColor}
        overflow="hidden"
      >
        <Table>
          <Thead>
            <Tr>
              <Th>Repository</Th>
              <Th>Status</Th>
              <Th>Insights</Th>
              <Th>Vulnerabilities</Th>
              <Th>Date</Th>
              <Th></Th>
            </Tr>
          </Thead>
          <Tbody>
            {isLoading ? (
              [...Array(ITEMS_PER_PAGE)].map((_, i) => (
                <Tr key={i}>
                  {[...Array(6)].map((_, j) => (
                    <Td key={j}>
                      <Box h="20px" w="100%" bg="gray.100" rounded="md" />
                    </Td>
                  ))}
                </Tr>
              ))
            ) : filteredAnalyses.length > 0 ? (
              filteredAnalyses.map((analysis: Analysis) => (
                <Tr key={analysis.id}>
                  <Td>
                    <Text fontWeight="medium">
                      {analysis.repository.owner}/{analysis.repository.name}
                    </Text>
                  </Td>
                  <Td>
                    <HStack>
                      {getStatusIcon(analysis.status)}
                      <Badge
                        colorScheme={
                          analysis.status === 'completed'
                            ? 'green'
                            : analysis.status === 'failed'
                            ? 'red'
                            : analysis.status === 'processing'
                            ? 'blue'
                            : 'yellow'
                        }
                      >
                        {analysis.status}
                      </Badge>
                    </HStack>
                  </Td>
                  <Td>
                    <HStack spacing={2}>
                      {Object.entries(
                        analysis.insights.reduce((acc: any, insight) => {
                          acc[insight.severity] = (acc[insight.severity] || 0) + 1;
                          return acc;
                        }, {})
                      ).map(([severity, count]) => (
                        <Badge
                          key={severity}
                          colorScheme={getSeverityColor(severity)}
                        >
                          {count}
                        </Badge>
                      ))}
                    </HStack>
                  </Td>
                  <Td>
                    <HStack spacing={2}>
                      {Object.entries(
                        analysis.vulnerabilities.reduce((acc: any, vuln) => {
                          acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
                          return acc;
                        }, {})
                      ).map(([severity, count]) => (
                        <Badge
                          key={severity}
                          colorScheme={getSeverityColor(severity)}
                        >
                          {count}
                        </Badge>
                      ))}
                    </HStack>
                  </Td>
                  <Td>
                    <Text color="gray.500">
                      {new Date(analysis.createdAt).toLocaleDateString()}
                    </Text>
                  </Td>
                  <Td>
                    <Button
                      as={RouterLink}
                      to={`/analyses/${analysis.id}`}
                      size="sm"
                      variant="ghost"
                    >
                      View Details
                    </Button>
                  </Td>
                </Tr>
              ))
            ) : (
              <Tr>
                <Td colSpan={6}>
                  <Stack align="center" spacing={4} py={8}>
                    <Icon as={FiSearch} boxSize={10} color="gray.400" />
                    <Text color="gray.500">No analyses found</Text>
                  </Stack>
                </Td>
              </Tr>
            )}
          </Tbody>
        </Table>
      </Box>

      {data?.pagination && (
        <Box py={4}>
          <Pagination
            currentPage={page}
            totalPages={Math.ceil(data.pagination.total / ITEMS_PER_PAGE)}
            onPageChange={setPage}
          />
        </Box>
      )}
    </Stack>
  );
}



================================================
File: client/src/pages/AnalysisDetailsPage.tsx
================================================
import {
  Accordion,
  AccordionButton,
  AccordionIcon,
  AccordionItem,
  AccordionPanel,
  Badge,
  Box,
  Button,
  Card,
  CardBody,
  CardHeader,
  Grid,
  Heading,
  HStack,
  Icon,
  Link,
  SimpleGrid,
  Spinner,
  Stack,
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  Tabs,
  Text,
  useColorModeValue,
  useDisclosure,
  useToast,
} from '@chakra-ui/react';
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import {
  FiAlertCircle,
  FiArrowLeft,
  FiCheck,
  FiClock,
  FiDownload,
  FiGitBranch,
  FiGithub,
  FiShare2,
  FiTrash2,
  FiXCircle,
} from 'react-icons/fi';
import { Link as RouterLink, useNavigate, useParams } from 'react-router-dom';
import { apiClient } from '@/lib/api';
import { ExportOptions } from '@/components/Analysis/ExportOptions';
import { ShareModal } from '@/components/Common/ShareModal';

interface Analysis {
  id: string;
  repositoryId: string;
  repository: {
    name: string;
    owner: string;
    url: string;
  };
  status: 'pending' | 'processing' | 'completed' | 'failed';
  createdAt: string;
  completedAt?: string;
  specifications: {
    overview: string;
    architecture: string;
    components: Array<{
      name: string;
      description: string;
      responsibility: string;
    }>;
  };
  insights: Array<{
    type: string;
    severity: string;
    message: string;
    file?: string;
    line?: number;
    recommendation?: string;
  }>;
  vulnerabilities: Array<{
    severity: string;
    title: string;
    description: string;
    file?: string;
    line?: number;
    recommendation: string;
    cwe?: string;
  }>;
}

export function AnalysisDetailsPage() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const toast = useToast();
  const cardBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  const {
    isOpen: isExportModalOpen,
    onOpen: onExportModalOpen,
    onClose: onExportModalClose,
  } = useDisclosure();
  const {
    isOpen: isShareModalOpen,
    onOpen: onShareModalOpen,
    onClose: onShareModalClose,
  } = useDisclosure();

  // Fetch analysis details
  const { data: analysis, isLoading } = useQuery<Analysis>(
    ['analysis', id],
    () => apiClient.analysis.get(id!).then((res) => res.data),
    {
      enabled: !!id,
    }
  );

  // Delete analysis mutation
  const deleteAnalysis = useMutation(
    () => apiClient.analysis.delete(id!),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['analyses']);
        toast({
          title: 'Analysis deleted',
          status: 'success',
          duration: 5000,
        });
        navigate('/analyses');
      },
      onError: (error: any) => {
        toast({
          title: 'Error deleting analysis',
          description: error.message,
          status: 'error',
          duration: 5000,
        });
      },
    }
  );

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'completed':
        return 'green';
      case 'failed':
        return 'red';
      case 'processing':
        return 'blue';
      default:
        return 'yellow';
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'completed':
        return FiCheck;
      case 'failed':
        return FiXCircle;
      case 'processing':
        return FiClock;
      default:
        return FiClock;
    }
  };

  const getSeverityColor = (severity: string) => {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 'red';
      case 'high':
        return 'orange';
      case 'medium':
        return 'yellow';
      case 'low':
        return 'green';
      default:
        return 'gray';
    }
  };

  if (isLoading) {
    return (
      <Stack align="center" justify="center" h="full" py={16}>
        <Spinner size="xl" color="brand.500" />
      </Stack>
    );
  }

  if (!analysis) {
    return (
      <Stack align="center" justify="center" h="full" py={16}>
        <Icon as={FiAlertCircle} boxSize={10} color="red.500" />
        <Text>Analysis not found</Text>
        <Button
          as={RouterLink}
          to="/analyses"
          leftIcon={<Icon as={FiArrowLeft} />}
        >
          Back to Analyses
        </Button>
      </Stack>
    );
  }

  return (
    <Stack spacing={8}>
      <Grid
        templateColumns={{ base: '1fr', md: '1fr auto' }}
        gap={4}
        alignItems="flex-start"
      >
        <Stack spacing={1}>
          <HStack>
            <Button
              as={RouterLink}
              to="/analyses"
              variant="ghost"
              leftIcon={<Icon as={FiArrowLeft} />}
              size="sm"
            >
              Back
            </Button>
            <Heading size="lg">Analysis Details</Heading>
          </HStack>
          <Text color="gray.500">
            Detailed analysis results and insights
          </Text>
        </Stack>

        <HStack>
          <Button
            leftIcon={<Icon as={FiShare2} />}
            variant="ghost"
            onClick={onShareModalOpen}
          >
            Share
          </Button>
          <Button
            leftIcon={<Icon as={FiDownload} />}
            onClick={onExportModalOpen}
          >
            Export
          </Button>
          <Button
            colorScheme="red"
            variant="ghost"
            leftIcon={<Icon as={FiTrash2} />}
            onClick={() => deleteAnalysis.mutate()}
            isLoading={deleteAnalysis.isLoading}
          >
            Delete Analysis
          </Button>
        </HStack>
      </Grid>

      {/* Analysis Overview */}
      <Card bg={cardBg}>
        <CardHeader>
          <Stack spacing={4}>
            <HStack justify="space-between">
              <Stack>
                <HStack>
                  <Icon as={FiGithub} />
                  <Link
                    href={analysis.repository.url}
                    target="_blank"
                    rel="noopener noreferrer"
                    fontWeight="semibold"
                  >
                    {analysis.repository.owner}/{analysis.repository.name}
                  </Link>
                </HStack>
                <HStack>
                  <Icon as={getStatusIcon(analysis.status)} />
                  <Badge colorScheme={getStatusColor(analysis.status)}>
                    {analysis.status}
                  </Badge>
                  <Text color="gray.500">
                    Started: {new Date(analysis.createdAt).toLocaleString()}
                  </Text>
                  {analysis.completedAt && (
                    <Text color="gray.500">
                      Completed: {new Date(analysis.completedAt).toLocaleString()}
                    </Text>
                  )}
                </HStack>
              </Stack>

              <Button
                as={RouterLink}
                to={`/repositories/${analysis.repositoryId}`}
                leftIcon={<Icon as={FiGitBranch} />}
                variant="ghost"
              >
                View Repository
              </Button>
            </HStack>
          </Stack>
        </CardHeader>
      </Card>

      {/* Analysis Results */}
      <Tabs>
        <TabList>
          <Tab>Overview</Tab>
          <Tab>Insights ({analysis.insights.length})</Tab>
          <Tab>Vulnerabilities ({analysis.vulnerabilities.length})</Tab>
          <Tab>Specifications</Tab>
        </TabList>

        <TabPanels>
          {/* Overview Panel */}
          <TabPanel>
            <SimpleGrid columns={{ base: 1, md: 2, lg: 3 }} spacing={6}>
              <Card>
                <CardHeader>
                  <Heading size="sm">Total Insights</Heading>
                </CardHeader>
                <CardBody>
                  <HStack spacing={4}>
                    {Object.entries(
                      analysis.insights.reduce((acc: any, insight) => {
                        acc[insight.severity] = (acc[insight.severity] || 0) + 1;
                        return acc;
                      }, {})
                    ).map(([severity, count]) => (
                      <Badge
                        key={severity}
                        colorScheme={getSeverityColor(severity)}
                      >
                        {severity}: {count}
                      </Badge>
                    ))}
                  </HStack>
                </CardBody>
              </Card>

              <Card>
                <CardHeader>
                  <Heading size="sm">Security Issues</Heading>
                </CardHeader>
                <CardBody>
                  <HStack spacing={4}>
                    {Object.entries(
                      analysis.vulnerabilities.reduce((acc: any, vuln) => {
                        acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
                        return acc;
                      }, {})
                    ).map(([severity, count]) => (
                      <Badge
                        key={severity}
                        colorScheme={getSeverityColor(severity)}
                      >
                        {severity}: {count}
                      </Badge>
                    ))}
                  </HStack>
                </CardBody>
              </Card>
            </SimpleGrid>
          </TabPanel>

          {/* Insights Panel */}
          <TabPanel>
            <Accordion allowMultiple>
              {analysis.insights.map((insight, index) => (
                <AccordionItem key={index}>
                  <AccordionButton>
                    <HStack flex="1" spacing={4}>
                      <Badge colorScheme={getSeverityColor(insight.severity)}>
                        {insight.severity}
                      </Badge>
                      <Text fontWeight="medium">{insight.message}</Text>
                    </HStack>
                    <AccordionIcon />
                  </AccordionButton>
                  <AccordionPanel>
                    <Stack spacing={4}>
                      {insight.file && (
                        <HStack>
                          <Text fontWeight="semibold">Location:</Text>
                          <Text>{insight.file}:{insight.line}</Text>
                        </HStack>
                      )}
                      {insight.recommendation && (
                        <Box>
                          <Text fontWeight="semibold">Recommendation:</Text>
                          <Text mt={2}>{insight.recommendation}</Text>
                        </Box>
                      )}
                    </Stack>
                  </AccordionPanel>
                </AccordionItem>
              ))}
            </Accordion>
          </TabPanel>

          {/* Vulnerabilities Panel */}
          <TabPanel>
            <Accordion allowMultiple>
              {analysis.vulnerabilities.map((vuln, index) => (
                <AccordionItem key={index}>
                  <AccordionButton>
                    <HStack flex="1" spacing={4}>
                      <Badge colorScheme={getSeverityColor(vuln.severity)}>
                        {vuln.severity}
                      </Badge>
                      <Text fontWeight="medium">{vuln.title}</Text>
                    </HStack>
                    <AccordionIcon />
                  </AccordionButton>
                  <AccordionPanel>
                    <Stack spacing={4}>
                      <Text>{vuln.description}</Text>
                      {vuln.file && (
                        <HStack>
                          <Text fontWeight="semibold">Location:</Text>
                          <Text>{vuln.file}:{vuln.line}</Text>
                        </HStack>
                      )}
                      <Box>
                        <Text fontWeight="semibold">Recommendation:</Text>
                        <Text mt={2}>{vuln.recommendation}</Text>
                      </Box>
                      {vuln.cwe && (
                        <Link
                          href={`https://cwe.mitre.org/data/definitions/${vuln.cwe}.html`}
                          target="_blank"
                          rel="noopener noreferrer"
                          color="brand.500"
                        >
                          Learn more about CWE-{vuln.cwe}
                        </Link>
                      )}
                    </Stack>
                  </AccordionPanel>
                </AccordionItem>
              ))}
            </Accordion>
          </TabPanel>

          {/* Specifications Panel */}
          <TabPanel>
            <Stack spacing={6}>
              <Card>
                <CardHeader>
                  <Heading size="sm">Project Overview</Heading>
                </CardHeader>
                <CardBody>
                  <Text whiteSpace="pre-wrap">{analysis.specifications.overview}</Text>
                </CardBody>
              </Card>

              <Card>
                <CardHeader>
                  <Heading size="sm">Architecture</Heading>
                </CardHeader>
                <CardBody>
                  <Text whiteSpace="pre-wrap">{analysis.specifications.architecture}</Text>
                </CardBody>
              </Card>

              <Card>
                <CardHeader>
                  <Heading size="sm">Components</Heading>
                </CardHeader>
                <CardBody>
                  <Stack spacing={4}>
                    {analysis.specifications.components.map((component, index) => (
                      <Box
                        key={index}
                        p={4}
                        borderWidth="1px"
                        borderColor={borderColor}
                        rounded="md"
                      >
                        <Stack spacing={2}>
                          <Heading size="sm">{component.name}</Heading>
                          <Text>{component.description}</Text>
                          <Text fontStyle="italic" color="gray.500">
                            Responsibility: {component.responsibility}
                          </Text>
                        </Stack>
                      </Box>
                    ))}
                  </Stack>
                </CardBody>
              </Card>
            </Stack>
          </TabPanel>
        </TabPanels>
      </Tabs>

      {/* Export Modal */}
      <ExportOptions
        analysisId={id!}
        isOpen={isExportModalOpen}
        onClose={onExportModalClose}
      />

      {/* Share Modal */}
      <ShareModal
        resourceId={id!}
        resourceType="analysis"
        isOpen={isShareModalOpen}
        onClose={onShareModalClose}
      />
    </Stack>
  );
}



================================================
File: client/src/pages/AuthCallbackPage.tsx
================================================
import { useEffect, useState } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { Box, Spinner, Center, VStack, Text, useToast } from '@chakra-ui/react';
import { useAuth } from '../contexts/AuthContext';

export function AuthCallbackPage() {
  const [error, setError] = useState<string | null>(null);
  const { handleAuthCallback } = useAuth();
  const navigate = useNavigate();
  const location = useLocation();
  const toast = useToast();

  useEffect(() => {
    async function processCallback() {
      const params = new URLSearchParams(location.search);
      const token = params.get('token');
      const errorParam = params.get('error');

      if (errorParam) {
        setError(errorParam);
        toast({
          title: 'Authentication Failed',
          description: `Error: ${errorParam}`,
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
        setTimeout(() => navigate('/login'), 3000);
        return;
      }

      if (!token) {
        setError('No authentication token received');
        toast({
          title: 'Authentication Failed',
          description: 'No token received from GitHub',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
        setTimeout(() => navigate('/login'), 3000);
        return;
      }

      try {
        await handleAuthCallback(token);
        toast({
          title: 'Authentication Successful',
          description: 'You have successfully logged in with GitHub.',
          status: 'success',
          duration: 3000,
          isClosable: true,
        });
        navigate('/');
      } catch (err) {
        setError('Failed to authenticate');
        toast({
          title: 'Authentication Failed',
          description: 'Could not complete the authentication process.',
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
        setTimeout(() => navigate('/login'), 3000);
      }
    }

    processCallback();
  }, [location, navigate, handleAuthCallback, toast]);

  return (
    <Center h="100vh">
      <VStack spacing={6}>
        {error ? (
          <>
            <Text fontSize="xl" fontWeight="bold" color="red.500">
              Authentication Error
            </Text>
            <Text>{error}</Text>
            <Text>Redirecting to login page...</Text>
          </>
        ) : (
          <>
            <Spinner size="xl" />
            <Box textAlign="center">
              <Text fontSize="xl" fontWeight="bold">
                Completing Authentication
              </Text>
              <Text mt={2}>Please wait while we complete the GitHub authentication...</Text>
            </Box>
          </>
        )}
      </VStack>
    </Center>
  );
}



================================================
File: client/src/pages/DashboardPage.tsx
================================================
import {
  Box,
  Button,
  Grid,
  Heading,
  Icon,
  Text,
  VStack,
  useColorModeValue,
  Tabs, TabList, TabPanels, Tab, TabPanel,
  Divider
} from '@chakra-ui/react';
import { FiGitBranch, FiStar } from 'react-icons/fi';
import { Link as RouterLink } from 'react-router-dom';
import { useEffect, useState } from 'react';
import { useAuth } from '../contexts/AuthContext';
import { SimpleRepositoryIngest } from '../components/SimpleRepositoryIngest';

interface Repository {
  id: number;
  name: string;
  fullName: string;
  description: string;
  stars: number;
  language: string;
}

export function DashboardPage() {
  const [repositories, setRepositories] = useState<Repository[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const cardBg = useColorModeValue('white', 'gray.800');
  const { user } = useAuth();

  useEffect(() => {
    fetchRepositories();
  }, []);

  const fetchRepositories = async () => {
    try {
      const token = localStorage.getItem('token');
      const response = await fetch('http://localhost:3030/api/repositories', {
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch repositories');
      }

      const data = await response.json();
      setRepositories(data.repositories || []);
    } catch (error) {
      console.error('Error fetching repositories:', error);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <VStack spacing={8} align="stretch">
      <Box>
        <Heading size="lg">Welcome, {user?.name || user?.login}</Heading>
        <Text mt={2} color="gray.500">
          Analyze GitHub repositories with AI
        </Text>
      </Box>
      
      <Tabs variant="enclosed" colorScheme="blue">
        <TabList>
          <Tab>Add Repository</Tab>
          <Tab>My Repositories</Tab>
        </TabList>
        <TabPanels>
          <TabPanel>
            <SimpleRepositoryIngest />
          </TabPanel>
          <TabPanel>
            {repositories.length > 0 ? (
              <Grid
                templateColumns={{
                  base: '1fr',
                  md: 'repeat(2, 1fr)',
                  lg: 'repeat(3, 1fr)',
                }}
                gap={6}
              >
                {repositories.map((repo) => (
                  <Box
                    key={repo.id}
                    p={6}
                    bg={cardBg}
                    rounded="lg"
                    shadow="sm"
                    borderWidth={1}
                    transition="all 0.2s"
                    _hover={{ shadow: 'md', transform: 'translateY(-2px)' }}
                  >
                    <VStack align="stretch" spacing={4}>
                      <Heading size="md" noOfLines={1}>
                        {repo.name}
                      </Heading>
                      {repo.description && (
                        <Text color="gray.500" noOfLines={2}>
                          {repo.description}
                        </Text>
                      )}
                      <Box>
                        {repo.language && (
                          <Text fontSize="sm" color="gray.500">
                            {repo.language}
                          </Text>
                        )}
                        <Text fontSize="sm" color="gray.500">
                          <Icon as={FiStar} mr={1} />
                          {repo.stars} stars
                        </Text>
                      </Box>
                      <Button
                        as={RouterLink}
                        to={`/repository/${repo.fullName}`}
                        colorScheme="blue"
                        size="sm"
                      >
                        View Analysis
                      </Button>
                    </VStack>
                  </Box>
                ))}
              </Grid>
            ) : (
              <Box textAlign="center" py={10}>
                <Text>No repositories found. Add a repository to get started.</Text>
              </Box>
            )}
          </TabPanel>
        </TabPanels>
      </Tabs>
    </VStack>
  );
}



================================================
File: client/src/pages/LoginPage.tsx
================================================
import {
  Box,
  Button,
  Center,
  Heading,
  Icon,
  Stack,
  Text,
  useColorModeValue,
  Divider,
  VStack,
} from '@chakra-ui/react';
import { FiGithub } from 'react-icons/fi';
import { Navigate } from 'react-router-dom';
import { useAuth } from '../contexts/AuthContext';
import { PublicRepositoryIngest } from '../components/PublicRepositoryIngest';

export function LoginPage() {
  const { user, login } = useAuth();
  const bg = useColorModeValue('white', 'gray.800');

  if (user) {
    return <Navigate to="/" replace />;
  }

  return (
    <Center minH="calc(100vh - 4rem)">
      <VStack 
        spacing={8} 
        align="center" 
        maxW="md"
        w="full"
        px={4}
      >
        <Box
          bg={bg}
          p={8}
          rounded="xl"
          shadow="lg"
          w="full"
          textAlign="center"
        >
          <Stack spacing={6}>
            <Stack spacing={2}>
              <Heading size="lg">Welcome to CodeInsight</Heading>
              <Text color="gray.500">
                Enhance your code understanding with AI-powered analysis
              </Text>
            </Stack>

            <Button
              size="lg"
              leftIcon={<Icon as={FiGithub} boxSize={5} />}
              onClick={login}
              colorScheme="blue"
            >
              Continue with GitHub
            </Button>

            <Text fontSize="sm" color="gray.500">
              By continuing, you agree to our Terms of Service and Privacy Policy
            </Text>
          </Stack>
        </Box>
        
        <PublicRepositoryIngest />
      </VStack>
    </Center>
  );
}



================================================
File: client/src/pages/NotFoundPage.tsx
================================================
import {
  Button,
  Container,
  Heading,
  Icon,
  Stack,
  Text,
} from '@chakra-ui/react';
import { FiArrowLeft, FiHome } from 'react-icons/fi';
import { Link as RouterLink, useNavigate } from 'react-router-dom';

export function NotFoundPage() {
  const navigate = useNavigate();

  return (
    <Container maxW="container.md" py={16}>
      <Stack spacing={8} align="center" textAlign="center">
        <Heading size="4xl">404</Heading>
        <Stack spacing={4}>
          <Heading size="xl">Page Not Found</Heading>
          <Text color="gray.500">
            The page you're looking for doesn't exist or has been moved.
          </Text>
        </Stack>

        <Stack direction={{ base: 'column', md: 'row' }} spacing={4}>
          <Button
            leftIcon={<Icon as={FiArrowLeft} />}
            onClick={() => navigate(-1)}
          >
            Go Back
          </Button>
          <Button
            as={RouterLink}
            to="/"
            leftIcon={<Icon as={FiHome} />}
            colorScheme="brand"
          >
            Return Home
          </Button>
        </Stack>
      </Stack>
    </Container>
  );
}



================================================
File: client/src/pages/ProfilePage.tsx
================================================
import {
  Avatar,
  Badge,
  Box,
  Button,
  Card,
  CardBody,
  CardHeader,
  Divider,
  Grid,
  Heading,
  HStack,
  Icon,
  Link,
  Stack,
  Switch,
  Text,
  useColorMode,
  useColorModeValue,
  useToast,
} from '@chakra-ui/react';
import { useMutation } from '@tanstack/react-query';
import {
  FiGithub,
  FiMail,
  FiMoon,
  FiShield,
  FiSun,
  FiTrash2,
} from 'react-icons/fi';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '@/contexts/AuthContext';
import { apiClient } from '@/lib/api';

export function ProfilePage() {
  const { user, logout } = useAuth();
  const navigate = useNavigate();
  const toast = useToast();
  const { colorMode, toggleColorMode } = useColorMode();
  const cardBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  // Delete account mutation
  const deleteAccount = useMutation(
    () => apiClient.auth.deleteAccount(),
    {
      onSuccess: () => {
        toast({
          title: 'Account deleted',
          description: 'Your account has been permanently deleted.',
          status: 'success',
          duration: 5000,
        });
        logout();
        navigate('/');
      },
      onError: (error: any) => {
        toast({
          title: 'Error deleting account',
          description: error.message,
          status: 'error',
          duration: 5000,
        });
      },
    }
  );

  // Revoke GitHub access mutation
  const revokeGitHubAccess = useMutation(
    () => apiClient.auth.revokeGitHub(),
    {
      onSuccess: () => {
        toast({
          title: 'GitHub access revoked',
          description: 'Successfully revoked GitHub access.',
          status: 'success',
          duration: 5000,
        });
        logout();
        navigate('/');
      },
      onError: (error: any) => {
        toast({
          title: 'Error revoking access',
          description: error.message,
          status: 'error',
          duration: 5000,
        });
      },
    }
  );

  if (!user) {
    return null;
  }

  return (
    <Stack spacing={8}>
      <Grid
        templateColumns={{ base: '1fr', md: '1fr auto' }}
        gap={4}
        alignItems="flex-start"
      >
        <Stack spacing={1}>
          <Heading size="lg">Profile Settings</Heading>
          <Text color="gray.500">
            Manage your account and preferences
          </Text>
        </Stack>
      </Grid>

      <Grid templateColumns={{ base: '1fr', lg: '2fr 1fr' }} gap={8}>
        {/* Main Settings */}
        <Stack spacing={6}>
          {/* Profile Information */}
          <Card bg={cardBg}>
            <CardHeader>
              <Heading size="md">Profile Information</Heading>
            </CardHeader>
            <CardBody>
              <Stack spacing={6}>
                <HStack spacing={4}>
                  <Avatar
                    size="xl"
                    name={user.name}
                    src={user.avatarUrl}
                  />
                  <Stack spacing={2}>
                    <Heading size="md">{user.name}</Heading>
                    <HStack>
                      <Icon as={FiMail} color="gray.500" />
                      <Text color="gray.500">{user.email}</Text>
                    </HStack>
                    <HStack>
                      <Icon as={FiGithub} color="gray.500" />
                      <Link
                        href={`https://github.com/${user.login}`}
                        target="_blank"
                        rel="noopener noreferrer"
                      >
                        {user.login}
                      </Link>
                    </HStack>
                  </Stack>
                </HStack>

                <Divider />

                <Stack spacing={4}>
                  <HStack justify="space-between">
                    <Stack spacing={1}>
                      <Text fontWeight="medium">GitHub Integration</Text>
                      <Text color="gray.500" fontSize="sm">
                        Manage your GitHub account connection
                      </Text>
                    </Stack>
                    <Button
                      colorScheme="red"
                      variant="ghost"
                      leftIcon={<Icon as={FiShield} />}
                      onClick={() => revokeGitHubAccess.mutate()}
                      isLoading={revokeGitHubAccess.isLoading}
                    >
                      Revoke Access
                    </Button>
                  </HStack>

                  <HStack>
                    <Badge colorScheme="green">Connected</Badge>
                    <Text color="gray.500" fontSize="sm">
                      Last synced: {new Date().toLocaleDateString()}
                    </Text>
                  </HStack>
                </Stack>
              </Stack>
            </CardBody>
          </Card>

          {/* Preferences */}
          <Card bg={cardBg}>
            <CardHeader>
              <Heading size="md">Preferences</Heading>
            </CardHeader>
            <CardBody>
              <Stack spacing={6}>
                <HStack justify="space-between">
                  <Stack spacing={1}>
                    <Text fontWeight="medium">Color Theme</Text>
                    <Text color="gray.500" fontSize="sm">
                      Choose your preferred color theme
                    </Text>
                  </Stack>
                  <HStack>
                    <Icon as={FiSun} />
                    <Switch
                      isChecked={colorMode === 'dark'}
                      onChange={toggleColorMode}
                    />
                    <Icon as={FiMoon} />
                  </HStack>
                </HStack>

                <Divider />

                <HStack justify="space-between">
                  <Stack spacing={1}>
                    <Text fontWeight="medium">Email Notifications</Text>
                    <Text color="gray.500" fontSize="sm">
                      Receive email notifications for analysis results
                    </Text>
                  </Stack>
                  <Switch defaultChecked />
                </HStack>

                <Divider />

                <HStack justify="space-between">
                  <Stack spacing={1}>
                    <Text fontWeight="medium">Security Alerts</Text>
                    <Text color="gray.500" fontSize="sm">
                      Get notified about critical security issues
                    </Text>
                  </Stack>
                  <Switch defaultChecked />
                </HStack>
              </Stack>
            </CardBody>
          </Card>
        </Stack>

        {/* Danger Zone */}
        <Card bg={cardBg} borderColor="red.500" borderWidth="1px">
          <CardHeader>
            <Heading size="md" color="red.500">
              Danger Zone
            </Heading>
          </CardHeader>
          <CardBody>
            <Stack spacing={6}>
              <Box
                p={4}
                bg={useColorModeValue('red.50', 'red.900')}
                rounded="md"
              >
                <Stack spacing={4}>
                  <Stack spacing={1}>
                    <Text fontWeight="medium">Delete Account</Text>
                    <Text color="gray.500" fontSize="sm">
                      Permanently delete your account and all associated data
                    </Text>
                  </Stack>
                  <Button
                    colorScheme="red"
                    leftIcon={<Icon as={FiTrash2} />}
                    onClick={() => deleteAccount.mutate()}
                    isLoading={deleteAccount.isLoading}
                  >
                    Delete Account
                  </Button>
                </Stack>
              </Box>
            </Stack>
          </CardBody>
        </Card>
      </Grid>
    </Stack>
  );
}



================================================
File: client/src/pages/RepositoriesPage.tsx
================================================
import {
  Box,
  Button,
  Grid,
  Heading,
  HStack,
  Icon,
  Input,
  InputGroup,
  InputLeftElement,
  Select,
  SimpleGrid,
  Skeleton,
  Stack,
  Text,
  useDisclosure,
} from '@chakra-ui/react';
import { useQuery } from '@tanstack/react-query';
import { useState } from 'react';
import { FiGitBranch, FiSearch } from 'react-icons/fi';
import { apiClient } from '@/lib/api';
import { RepositoryCard } from '@/components/Repository/RepositoryCard';
import { AddRepositoryModal } from '@/components/Repository/AddRepositoryModal';
import { Pagination } from '@/components/Common/Pagination';

const ITEMS_PER_PAGE = 12;

export function RepositoriesPage() {
  const [page, setPage] = useState(1);
  const [search, setSearch] = useState('');
  const [sort, setSort] = useState('newest');
  const { isOpen, onOpen, onClose } = useDisclosure();

  // Fetch repositories with search and pagination
  const {
    data,
    isLoading,
    error,
  } = useQuery(
    ['repositories', page, search, sort],
    () => apiClient.repositories.list(page, ITEMS_PER_PAGE),
    {
      select: (response) => response.data,
      keepPreviousData: true,
    }
  );

  // Filter and sort repositories
  const repositories = data?.repositories || [];
  const filteredRepositories = repositories
    .filter((repo) =>
      repo.name.toLowerCase().includes(search.toLowerCase()) ||
      repo.description?.toLowerCase().includes(search.toLowerCase())
    )
    .sort((a, b) => {
      if (sort === 'newest') {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      }
      if (sort === 'oldest') {
        return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
      }
      if (sort === 'name') {
        return a.name.localeCompare(b.name);
      }
      if (sort === 'lastAnalyzed') {
        const aDate = a.lastAnalysis?.createdAt || '0';
        const bDate = b.lastAnalysis?.createdAt || '0';
        return new Date(bDate).getTime() - new Date(aDate).getTime();
      }
      return 0;
    });

  if (error) {
    return (
      <Stack spacing={4} align="center" justify="center" h="full" py={16}>
        <Icon as={FiGitBranch} boxSize={10} color="red.500" />
        <Text>Failed to load repositories</Text>
        <Button onClick={() => window.location.reload()}>
          Retry
        </Button>
      </Stack>
    );
  }

  return (
    <Stack spacing={8}>
      <Grid
        templateColumns={{ base: '1fr', md: '1fr auto' }}
        gap={4}
        alignItems="flex-start"
      >
        <Stack spacing={1}>
          <Heading size="lg">Repositories</Heading>
          <Text color="gray.500">
            Manage and analyze your GitHub repositories
          </Text>
        </Stack>

        <Button
          leftIcon={<Icon as={FiGitBranch} />}
          onClick={onOpen}
        >
          Add Repository
        </Button>
      </Grid>

      <HStack spacing={4}>
        <InputGroup maxW={{ base: 'full', md: '320px' }}>
          <InputLeftElement>
            <Icon as={FiSearch} color="gray.400" />
          </InputLeftElement>
          <Input
            placeholder="Search repositories..."
            value={search}
            onChange={(e) => setSearch(e.target.value)}
          />
        </InputGroup>

        <Select
          value={sort}
          onChange={(e) => setSort(e.target.value)}
          w={{ base: 'full', md: '200px' }}
        >
          <option value="newest">Newest First</option>
          <option value="oldest">Oldest First</option>
          <option value="name">Name</option>
          <option value="lastAnalyzed">Last Analyzed</option>
        </Select>
      </HStack>

      {isLoading ? (
        <SimpleGrid columns={{ base: 1, md: 2, lg: 3 }} spacing={6}>
          {[...Array(ITEMS_PER_PAGE)].map((_, i) => (
            <Skeleton key={i} height="200px" rounded="lg" />
          ))}
        </SimpleGrid>
      ) : filteredRepositories.length > 0 ? (
        <>
          <SimpleGrid columns={{ base: 1, md: 2, lg: 3 }} spacing={6}>
            {filteredRepositories.map((repository) => (
              <RepositoryCard
                key={repository.id}
                repository={repository}
              />
            ))}
          </SimpleGrid>

          <Box py={4}>
            <Pagination
              currentPage={page}
              totalPages={Math.ceil((data?.pagination.total || 0) / ITEMS_PER_PAGE)}
              onPageChange={setPage}
            />
          </Box>
        </>
      ) : (
        <Stack spacing={4} align="center" justify="center" py={16}>
          <Icon as={FiGitBranch} boxSize={10} color="gray.400" />
          <Text color="gray.500">No repositories found</Text>
          <Button onClick={onOpen}>
            Add Repository
          </Button>
        </Stack>
      )}

      <AddRepositoryModal
        isOpen={isOpen}
        onClose={onClose}
      />
    </Stack>
  );
}



================================================
File: client/src/pages/RepositoryDetailsPage.tsx
================================================
import {
  Box,
  Button,
  Card,
  CardBody,
  CardHeader,
  Grid,
  Heading,
  HStack,
  Icon,
  Link,
  Stack,
  Tab,
  TabList,
  TabPanel,
  TabPanels,
  Tabs,
  Text,
  useColorModeValue,
  useDisclosure,
  useToast,
} from '@chakra-ui/react';
import { useMutation, useQuery } from '@tanstack/react-query';
import {
  FiAlertCircle,
  FiGithub,
  FiPlay,
  FiShare2,
} from 'react-icons/fi';
import { Link as RouterLink, useParams } from 'react-router-dom';
import { FileTreeNavigator } from '@/components/Repository/FileTreeNavigator';
import { ShareModal } from '@/components/Common/ShareModal';
import { apiClient } from '@/lib/api';

interface Repository {
  id: string;
  name: string;
  owner: string;
  description: string;
  url: string;
  defaultBranch: string;
  lastAnalysis?: {
    id: string;
    status: string;
    createdAt: string;
  };
}

export function RepositoryDetailsPage() {
  const { id } = useParams<{ id: string }>();
  const toast = useToast();
  const cardBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  const {
    isOpen: isShareModalOpen,
    onOpen: onShareModalOpen,
    onClose: onShareModalClose,
  } = useDisclosure();

  // Fetch repository details
  const { data: repository, isLoading } = useQuery<Repository>(
    ['repository', id],
    () => apiClient.repositories.get(id!).then((res) => res.data),
    {
      enabled: !!id,
    }
  );

  // Start analysis mutation
  const startAnalysis = useMutation(
    () => apiClient.analysis.start(id!),
    {
      onSuccess: (response) => {
        toast({
          title: 'Analysis started',
          description: 'The repository analysis has been initiated.',
          status: 'success',
          duration: 5000,
        });
      },
      onError: (error: any) => {
        toast({
          title: 'Failed to start analysis',
          description: error.message,
          status: 'error',
          duration: 5000,
        });
      },
    }
  );

  const [selectedFile, setSelectedFile] = useState<string | null>(null);

  // Fetch file content when a file is selected
  const { data: fileContent } = useQuery(
    ['repository', id, 'file', selectedFile],
    () =>
      apiClient.repositories.getFileContent(id!, selectedFile!),
    {
      enabled: !!id && !!selectedFile,
    }
  );

  if (isLoading || !repository) {
    return (
      <Stack align="center" justify="center" h="full" py={16}>
        <Icon as={FiAlertCircle} boxSize={10} color="red.500" />
        <Text>Repository not found</Text>
        <Button
          as={RouterLink}
          to="/repositories"
          leftIcon={<Icon as={FiArrowLeft} />}
        >
          Back to Repositories
        </Button>
      </Stack>
    );
  }

  return (
    <Stack spacing={8}>
      <Grid
        templateColumns={{ base: '1fr', md: '1fr auto' }}
        gap={4}
        alignItems="flex-start"
      >
        <Stack spacing={1}>
          <HStack>
            <Icon as={FiGithub} />
            <Heading size="lg">
              {repository.owner}/{repository.name}
            </Heading>
          </HStack>
          <Text color="gray.500">{repository.description}</Text>
        </Stack>

        <HStack>
          <Button
            leftIcon={<Icon as={FiShare2} />}
            variant="ghost"
            onClick={onShareModalOpen}
          >
            Share
          </Button>
          <Button
            leftIcon={<Icon as={FiPlay} />}
            onClick={() => startAnalysis.mutate()}
            isLoading={startAnalysis.isLoading}
            loadingText="Starting..."
          >
            Start Analysis
          </Button>
        </HStack>
      </Grid>

      <Grid templateColumns={{ base: '1fr', lg: '300px 1fr' }} gap={8}>
        {/* File Tree */}
        <Stack spacing={4}>
          <Card bg={cardBg}>
            <CardHeader>
              <Heading size="sm">Repository Files</Heading>
            </CardHeader>
            <CardBody p={0}>
              <FileTreeNavigator
                repositoryId={id!}
                onFileSelect={setSelectedFile}
                selectedPath={selectedFile}
              />
            </CardBody>
          </Card>
        </Stack>

        {/* Main Content */}
        <Stack spacing={6}>
          <Tabs>
            <TabList>
              <Tab>Overview</Tab>
              <Tab>Files</Tab>
              <Tab>Analyses</Tab>
            </TabList>

            <TabPanels>
              {/* Overview Panel */}
              <TabPanel>
                <Stack spacing={6}>
                  <Card>
                    <CardHeader>
                      <Heading size="sm">Repository Information</Heading>
                    </CardHeader>
                    <CardBody>
                      <Stack spacing={4}>
                        <HStack>
                          <Text fontWeight="medium">GitHub URL:</Text>
                          <Link
                            href={repository.url}
                            target="_blank"
                            rel="noopener noreferrer"
                            color="brand.500"
                          >
                            {repository.url}
                          </Link>
                        </HStack>
                        <HStack>
                          <Text fontWeight="medium">Default Branch:</Text>
                          <Text>{repository.defaultBranch}</Text>
                        </HStack>
                        {repository.lastAnalysis && (
                          <HStack>
                            <Text fontWeight="medium">Last Analysis:</Text>
                            <Link
                              as={RouterLink}
                              to={`/analyses/${repository.lastAnalysis.id}`}
                              color="brand.500"
                            >
                              {new Date(
                                repository.lastAnalysis.createdAt
                              ).toLocaleDateString()}
                            </Link>
                          </HStack>
                        )}
                      </Stack>
                    </CardBody>
                  </Card>
                </Stack>
              </TabPanel>

              {/* Files Panel */}
              <TabPanel>
                <Card>
                  <CardBody>
                    {selectedFile ? (
                      <Stack spacing={4}>
                        <HStack justify="space-between">
                          <Text fontWeight="medium">{selectedFile}</Text>
                          <Button
                            size="sm"
                            variant="ghost"
                            onClick={() => setSelectedFile(null)}
                          >
                            Close
                          </Button>
                        </HStack>
                        <Box
                          p={4}
                          bg={useColorModeValue('gray.50', 'gray.700')}
                          borderRadius="md"
                          fontFamily="monospace"
                          fontSize="sm"
                          whiteSpace="pre-wrap"
                          overflowX="auto"
                        >
                          {fileContent}
                        </Box>
                      </Stack>
                    ) : (
                      <Text color="gray.500">
                        Select a file from the tree to view its contents
                      </Text>
                    )}
                  </CardBody>
                </Card>
              </TabPanel>

              {/* Analyses Panel */}
              <TabPanel>
                <Card>
                  <CardHeader>
                    <Heading size="sm">Analysis History</Heading>
                  </CardHeader>
                  <CardBody>
                    {/* Analysis history list component will go here */}
                  </CardBody>
                </Card>
              </TabPanel>
            </TabPanels>
          </Tabs>
        </Stack>
      </Grid>

      {/* Share Modal */}
      <ShareModal
        resourceId={id!}
        resourceType="repository"
        isOpen={isShareModalOpen}
        onClose={onShareModalClose}
      />
    </Stack>
  );
}



================================================
File: client/src/pages/RepositoryPage.tsx
================================================
import {
  Box,
  Container,
  Heading,
  Spinner,
  Text,
  VStack,
} from '@chakra-ui/react';
import { useParams } from 'react-router-dom';

export function RepositoryPage() {
  const { owner, name } = useParams();

  return (
    <Container maxW="container.xl" py={8}>
      <VStack spacing={6} align="stretch">
        <Heading size="lg">
          {owner}/{name}
        </Heading>
        <Box p={6} borderWidth={1} rounded="lg">
          <Text>Analysis in progress...</Text>
        </Box>
      </VStack>
    </Container>
  );
}



================================================
File: client/src/pages/SecurityPage.tsx
================================================
import {
  Badge,
  Box,
  Button,
  Card,
  CardBody,
  CardHeader,
  Grid,
  Heading,
  HStack,
  Icon,
  Link,
  Select,
  SimpleGrid,
  Spinner,
  Stack,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';
import { useQuery } from '@tanstack/react-query';
import {
  FiAlertCircle,
  FiAlertTriangle,
  FiShield,
  FiShieldOff,
} from 'react-icons/fi';
import { Link as RouterLink } from 'react-router-dom';
import { apiClient } from '@/lib/api';

interface SecurityIssue {
  id: string;
  analysisId: string;
  repository: {
    id: string;
    name: string;
    owner: string;
  };
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  description: string;
  file?: string;
  line?: number;
  cwe?: string;
  recommendation: string;
  createdAt: string;
}

export function SecurityPage() {
  const cardBg = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  // Fetch security issues across all analyses
  const { data, isLoading, error } = useQuery(
    ['security-issues'],
    async () => {
      const analyses = await apiClient.analysis.list(1, 100).then(res => res.data.analyses);
      return analyses.reduce((issues: SecurityIssue[], analysis: any) => {
        const vulnerabilities = analysis.vulnerabilities.map((vuln: any) => ({
          id: `${analysis.id}-${vuln.id}`,
          analysisId: analysis.id,
          repository: analysis.repository,
          ...vuln,
        }));
        return [...issues, ...vulnerabilities];
      }, []);
    }
  );

  const getSeverityColor = (severity: string) => {
    switch (severity.toLowerCase()) {
      case 'critical':
        return 'red';
      case 'high':
        return 'orange';
      case 'medium':
        return 'yellow';
      case 'low':
        return 'green';
      default:
        return 'gray';
    }
  };

  const getSeverityIcon = (severity: string) => {
    switch (severity.toLowerCase()) {
      case 'critical':
      case 'high':
        return FiAlertCircle;
      case 'medium':
        return FiAlertTriangle;
      case 'low':
        return FiShieldOff;
      default:
        return FiShield;
    }
  };

  if (isLoading) {
    return (
      <Stack align="center" justify="center" h="full" py={16}>
        <Spinner size="xl" color="brand.500" />
      </Stack>
    );
  }

  if (error) {
    return (
      <Stack align="center" justify="center" h="full" py={16}>
        <Icon as={FiAlertCircle} boxSize={10} color="red.500" />
        <Text>Failed to load security issues</Text>
        <Button onClick={() => window.location.reload()}>
          Retry
        </Button>
      </Stack>
    );
  }

  const issues = data || [];
  const severityCounts = issues.reduce((acc: Record<string, number>, issue) => {
    acc[issue.severity] = (acc[issue.severity] || 0) + 1;
    return acc;
  }, {});

  return (
    <Stack spacing={8}>
      <Grid
        templateColumns={{ base: '1fr', md: '1fr auto' }}
        gap={4}
        alignItems="flex-start"
      >
        <Stack spacing={1}>
          <Heading size="lg">Security Overview</Heading>
          <Text color="gray.500">
            Comprehensive view of security vulnerabilities across all repositories
          </Text>
        </Stack>
      </Grid>

      {/* Security Summary */}
      <SimpleGrid columns={{ base: 1, md: 2, lg: 4 }} spacing={6}>
        {['critical', 'high', 'medium', 'low'].map((severity) => (
          <Card
            key={severity}
            bg={cardBg}
            borderWidth="1px"
            borderColor={
              severityCounts[severity] > 0
                ? `${getSeverityColor(severity)}.500`
                : borderColor
            }
          >
            <CardBody>
              <Stack spacing={4}>
                <HStack>
                  <Icon
                    as={getSeverityIcon(severity)}
                    color={`${getSeverityColor(severity)}.500`}
                    boxSize={6}
                  />
                  <Text
                    textTransform="capitalize"
                    fontWeight="medium"
                    color={`${getSeverityColor(severity)}.500`}
                  >
                    {severity}
                  </Text>
                </HStack>
                <Heading size="2xl">{severityCounts[severity] || 0}</Heading>
              </Stack>
            </CardBody>
          </Card>
        ))}
      </SimpleGrid>

      {/* Security Issues List */}
      <Card bg={cardBg}>
        <CardHeader>
          <HStack justify="space-between">
            <Heading size="md">Security Issues</Heading>
            <Select
              w="200px"
              defaultValue="all"
              onChange={(e) => {
                // TODO: Implement filtering by severity
              }}
            >
              <option value="all">All Severities</option>
              <option value="critical">Critical</option>
              <option value="high">High</option>
              <option value="medium">Medium</option>
              <option value="low">Low</option>
            </Select>
          </HStack>
        </CardHeader>
        <CardBody>
          <Stack spacing={4}>
            {issues.length > 0 ? (
              issues.map((issue) => (
                <Box
                  key={issue.id}
                  p={4}
                  borderWidth="1px"
                  borderColor={borderColor}
                  rounded="lg"
                >
                  <Stack spacing={4}>
                    <HStack justify="space-between">
                      <HStack>
                        <Badge
                          colorScheme={getSeverityColor(issue.severity)}
                          display="flex"
                          alignItems="center"
                          px={2}
                          py={1}
                        >
                          <Icon
                            as={getSeverityIcon(issue.severity)}
                            mr={1}
                          />
                          {issue.severity}
                        </Badge>
                        <Text fontWeight="medium">{issue.title}</Text>
                      </HStack>
                      <Link
                        as={RouterLink}
                        to={`/analyses/${issue.analysisId}`}
                        color="brand.500"
                      >
                        View Analysis
                      </Link>
                    </HStack>

                    <Stack spacing={2}>
                      <Text color="gray.500">
                        {issue.repository.owner}/{issue.repository.name}
                      </Text>
                      <Text>{issue.description}</Text>
                      {issue.file && (
                        <Text fontSize="sm" color="gray.500">
                          Location: {issue.file}:{issue.line}
                        </Text>
                      )}
                    </Stack>

                    <Box
                      bg={useColorModeValue('gray.50', 'gray.700')}
                      p={4}
                      rounded="md"
                    >
                      <Stack spacing={2}>
                        <Text fontWeight="medium">Recommendation</Text>
                        <Text>{issue.recommendation}</Text>
                      </Stack>
                    </Box>

                    {issue.cwe && (
                      <Link
                        href={`https://cwe.mitre.org/data/definitions/${issue.cwe}.html`}
                        target="_blank"
                        rel="noopener noreferrer"
                        color="brand.500"
                        fontSize="sm"
                      >
                        Learn more about CWE-{issue.cwe}
                      </Link>
                    )}
                  </Stack>
                </Box>
              ))
            ) : (
              <Stack align="center" spacing={4} py={8}>
                <Icon as={FiShield} boxSize={10} color="green.500" />
                <Text>No security issues found</Text>
                <Text color="gray.500">
                  All your repositories are currently secure
                </Text>
              </Stack>
            )}
          </Stack>
        </CardBody>
      </Card>
    </Stack>
  );
}



================================================
File: client/src/routes/ProtectedRoute.tsx
================================================
import { Navigate, Outlet } from 'react-router-dom';
import { Center, Spinner } from '@chakra-ui/react';
import { useAuth } from '@/contexts/AuthContext';

export function ProtectedRoute() {
  const { user, isLoading } = useAuth();

  if (isLoading) {
    return (
      <Center h="100vh">
        <Spinner size="xl" color="brand.500" />
      </Center>
    );
  }

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  return <Outlet />;
}



================================================
File: client/src/routes/index.tsx
================================================
import { Navigate, Route, Routes } from 'react-router-dom';
import { ProtectedRoute } from './ProtectedRoute';
import { LoginPage } from '@/pages/LoginPage';
import { DashboardPage } from '@/pages/DashboardPage';
import { RepositoriesPage } from '@/pages/RepositoriesPage';
import { RepositoryDetailsPage } from '@/pages/RepositoryDetailsPage';
import { AnalysesPage } from '@/pages/AnalysesPage';
import { AnalysisDetailsPage } from '@/pages/AnalysisDetailsPage';
import { SecurityPage } from '@/pages/SecurityPage';
import { ProfilePage } from '@/pages/ProfilePage';
import { NotFoundPage } from '@/pages/NotFoundPage';

export function AppRoutes() {
  return (
    <Routes>
      {/* Public routes */}
      <Route path="/login" element={<LoginPage />} />
      
      {/* Protected routes */}
      <Route element={<ProtectedRoute />}>
        <Route path="/" element={<Navigate to="/dashboard" replace />} />
        <Route path="/dashboard" element={<DashboardPage />} />
        
        <Route path="/repositories">
          <Route index element={<RepositoriesPage />} />
          <Route path=":id" element={<RepositoryDetailsPage />} />
        </Route>
        
        <Route path="/analyses">
          <Route index element={<AnalysesPage />} />
          <Route path=":id" element={<AnalysisDetailsPage />} />
        </Route>
        
        <Route path="/security" element={<SecurityPage />} />
        <Route path="/profile" element={<ProfilePage />} />
      </Route>

      {/* Catch all route */}
      <Route path="*" element={<NotFoundPage />} />
    </Routes>
  );
}



================================================
File: client/src/types/analysis.ts
================================================
export type AnalysisStatus = 'pending' | 'processing' | 'completed' | 'failed';

export interface Insight {
  type: string;
  content: string;
  path?: string;
  severity?: 'info' | 'warning' | 'error';
}

export interface Vulnerability {
  type: string;
  description: string;
  path?: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  recommendation?: string;
}

export interface Specifications {
  overview?: string;
  architecture?: string;
  dependencies?: string;
  setup?: string;
}

export interface Analysis {
  id: string;
  _id: string;
  userId: string;
  repositoryId: string;
  status: AnalysisStatus;
  insights: Insight[];
  vulnerabilities: Vulnerability[];
  specifications: Specifications;
  createdAt: string;
  updatedAt: string;
}

export interface AnalysisResponse {
  data: Analysis[];
  total: number;
  page: number;
  limit: number;
}



================================================
File: client/src/types/axios.d.ts
================================================
declare module 'axios' {
  import { AxiosRequestConfig, AxiosResponse } from 'axios';

  export interface AxiosInstance {
    request<T = any>(config: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    get<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    delete<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    head<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    options<T = any>(url: string, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    post<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    put<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
    patch<T = any>(url: string, data?: any, config?: AxiosRequestConfig): Promise<AxiosResponse<T>>;
  }

  export interface AxiosResponse<T = any> {
    data: T;
    status: number;
    statusText: string;
    headers: any;
    config: AxiosRequestConfig;
    request?: any;
  }

  export interface AxiosError<T = any> extends Error {
    config: AxiosRequestConfig;
    code?: string;
    request?: any;
    response?: AxiosResponse<T>;
    isAxiosError: boolean;
    toJSON: () => object;
  }

  export interface AxiosRequestConfig {
    url?: string;
    method?: string;
    baseURL?: string;
    headers?: any;
    params?: any;
    data?: any;
    timeout?: number;
    withCredentials?: boolean;
    responseType?: string;
    xsrfCookieName?: string;
    xsrfHeaderName?: string;
    onUploadProgress?: (progressEvent: any) => void;
    onDownloadProgress?: (progressEvent: any) => void;
    maxContentLength?: number;
    validateStatus?: (status: number) => boolean;
    maxRedirects?: number;
    socketPath?: string | null;
    httpAgent?: any;
    httpsAgent?: any;
  }

  export interface AxiosStatic extends AxiosInstance {
    create(config?: AxiosRequestConfig): AxiosInstance;
    Cancel: CancelStatic;
    CancelToken: CancelTokenStatic;
    isCancel(value: any): boolean;
    all<T>(values: (T | Promise<T>)[]): Promise<T[]>;
    spread<T, R>(callback: (...args: T[]) => R): (array: T[]) => R;
  }

  export interface Cancel {
    message: string;
  }

  export interface CancelToken {
    promise: Promise<Cancel>;
    reason?: Cancel;
    throwIfRequested(): void;
  }

  export interface Canceler {
    (message?: string): void;
  }

  export interface CancelTokenSource {
    token: CancelToken;
    cancel: Canceler;
  }

  export interface CancelTokenStatic {
    new (executor: (cancel: Canceler) => void): CancelToken;
    source(): CancelTokenSource;
  }

  export interface CancelStatic {
    new (message?: string): Cancel;
  }

  declare const axios: AxiosStatic;
  export default axios;
}



================================================
File: client/src/types/global.d.ts
================================================
declare global {
  interface Window {
    env: {
      REACT_APP_API_URL?: string;
    };
  }
}

export {};



================================================
File: client/src/types/jest.d.ts
================================================
/// <reference types="jest" />

declare global {
  const jest: typeof import('@jest/globals').jest;
  const expect: typeof import('@jest/globals').expect;
  const describe: typeof import('@jest/globals').describe;
  const it: typeof import('@jest/globals').it;
  const beforeEach: typeof import('@jest/globals').beforeEach;
  const afterEach: typeof import('@jest/globals').afterEach;
}



================================================
File: common/package.json
================================================
{
  "name": "@codeinsight/common",
  "version": "1.0.0",
  "private": true,
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "lint": "eslint src --ext .ts"
  },
  "dependencies": {
    "axios": "^1.6.7",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/axios": "^0.14.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.45.0",
    "typescript": "^5.0.0"
  }
}



================================================
File: common/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "declaration": true,
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



================================================
File: common/src/index.ts
================================================
export * from './types/analysis';
export * from './types/user';
export * from './types/error';

export const API_ROUTES = {
  AUTH: {
    GITHUB_LOGIN: '/auth/github',
    GITHUB_CALLBACK: '/auth/github/callback',
    LOGOUT: '/auth/logout',
  },
  REPOSITORIES: {
    LIST: '/repositories',
    GET: (id: string) => `/repositories/${id}`,
    ANALYZE: (id: string) => `/repositories/${id}/analyze`,
  },
  ANALYSIS: {
    LIST: '/analysis',
    GET: (id: string) => `/analysis/${id}`,
    SHARE: (id: string) => `/analysis/${id}/share`,
  },
} as const;

export const CONFIG = {
  API_URL: process.env.API_URL || 'http://localhost:3000',
  GITHUB_API_URL: 'https://api.github.com',
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB
  RATE_LIMIT: {
    WINDOW_MS: 15 * 60 * 1000, // 15 minutes
    MAX_REQUESTS: 100,
  },
} as const;



================================================
File: common/src/types/analysis.ts
================================================
import { z } from 'zod';

export const AnalysisStatusSchema = z.enum(['pending', 'processing', 'completed', 'failed']);
export type AnalysisStatus = z.infer<typeof AnalysisStatusSchema>;

export const RepositorySchema = z.object({
  id: z.string(),
  name: z.string(),
  owner: z.string(),
  url: z.string().url(),
  description: z.string().optional(),
  branch: z.string(),
  private: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
});
export type Repository = z.infer<typeof RepositorySchema>;

export const AnalysisResultSchema = z.object({
  id: z.string(),
  repositoryId: z.string(),
  status: AnalysisStatusSchema,
  insights: z.array(z.object({
    type: z.string(),
    content: z.string(),
    severity: z.enum(['info', 'warning', 'critical']).optional(),
    path: z.string().optional(),
  })),
  vulnerabilities: z.array(z.object({
    title: z.string(),
    description: z.string(),
    severity: z.enum(['low', 'medium', 'high', 'critical']),
    path: z.string(),
    line: z.number().optional(),
    recommendation: z.string(),
  })),
  specifications: z.object({
    overview: z.string(),
    architecture: z.string(),
    components: z.array(z.object({
      name: z.string(),
      description: z.string(),
      dependencies: z.array(z.string()),
    })),
  }),
  createdAt: z.date(),
  updatedAt: z.date(),
});
export type AnalysisResult = z.infer<typeof AnalysisResultSchema>;



================================================
File: common/src/types/error.ts
================================================
import { z } from 'zod';

export const ErrorCodeSchema = z.enum([
  'BAD_REQUEST',
  'UNAUTHORIZED',
  'FORBIDDEN',
  'NOT_FOUND',
  'RATE_LIMITED',
  'VALIDATION_ERROR',
  'GITHUB_API_ERROR',
  'CLAUDE_API_ERROR',
  'INTERNAL_SERVER_ERROR'
]);
export type ErrorCode = z.infer<typeof ErrorCodeSchema>;

export const ApiErrorSchema = z.object({
  code: ErrorCodeSchema,
  message: z.string(),
  details: z.record(z.unknown()).optional(),
  stack: z.string().optional(),
});
export type ApiError = z.infer<typeof ApiErrorSchema>;

export class ApiException extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public details?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'ApiException';
  }

  toJSON(): ApiError {
    return {
      code: this.code,
      message: this.message,
      details: this.details,
      stack: process.env.NODE_ENV === 'development' ? this.stack : undefined,
    };
  }
}



================================================
File: common/src/types/user.ts
================================================
import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string(),
  githubId: z.number(),
  username: z.string(),
  email: z.string().email(),
  avatarUrl: z.string().url(),
  name: z.string().optional(),
  accessToken: z.string(),
  createdAt: z.date(),
  updatedAt: z.date(),
});
export type User = z.infer<typeof UserSchema>;

export const AuthResponseSchema = z.object({
  user: UserSchema,
  token: z.string(), // JWT token
});
export type AuthResponse = z.infer<typeof AuthResponseSchema>;

export const GithubAuthSchema = z.object({
  code: z.string(),
  state: z.string(),
});
export type GithubAuth = z.infer<typeof GithubAuthSchema>;



================================================
File: server/package.json
================================================
{
  "name": "@codeinsight/server",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "dev:simple": "ts-node-dev --respawn --transpile-only src/index-simple.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "lint": "eslint src --ext .ts",
    "test": "jest"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.10.2",
    "@octokit/rest": "^21.1.1",
    "axios": "^1.8.3",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.21.2",
    "express-rate-limit": "^7.5.0",
    "helmet": "^7.0.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^7.5.0",
    "redis": "^4.6.8",
    "simple-git": "^3.19.1",
    "winston": "^3.10.0",
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "@types/cookie-parser": "^1.4.8",
    "@types/cors": "^2.8.13",
    "@types/express": "^4.17.17",
    "@types/jest": "^29.5.3",
    "@types/jsonwebtoken": "^9.0.9",
    "@types/node": "^20.5.0",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "eslint": "^8.45.0",
    "jest": "^29.6.2",
    "ts-jest": "^29.1.1",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.0.0"
  }
}



================================================
File: server/tsconfig.json
================================================
{
  "extends": "../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "baseUrl": "src",
    "paths": {
      "@/*": ["*"]
    },
    "typeRoots": ["./node_modules/@types", "./src/types"],
    "module": "CommonJS",
    "target": "ES2020"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}



================================================
File: server/.env.dev
================================================
# Server Configuration
PORT=3030
NODE_ENV=development

# Database Configuration
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/codeinsight
REDIS_URL=redis://localhost:6379

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=placeholder_github_id
GITHUB_CLIENT_SECRET=placeholder_github_secret
GITHUB_CALLBACK_URL=http://localhost:3030/api/auth/github/callback

# Claude AI Configuration
ANTHROPIC_API_KEY=placeholder_anthropic_key
CLAUDE_API_KEY=placeholder_claude_key

# JWT Configuration
JWT_SECRET=temporary_dev_jwt_secret_at_least_32_chars_long
JWT_EXPIRES_IN=7d

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100



================================================
File: server/.env.example
================================================
# Server Configuration
PORT=3030
NODE_ENV=development

# Database Configuration
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/codeinsight

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret
GITHUB_CALLBACK_URL=http://localhost:3030/api/auth/github/callback

# Claude AI Configuration
CLAUDE_API_KEY=your_claude_api_key

# JWT Configuration
JWT_SECRET=your_jwt_secret_at_least_32_chars_long
JWT_EXPIRES_IN=7d

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000  # 15 minutes
RATE_LIMIT_MAX_REQUESTS=100



================================================
File: server/src/app.ts
================================================
import express from 'express';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { authRouter } from './routes/auth.routes';
import { repoRouter } from './routes/repo.routes';
import { analysisRouter } from './routes/analysis.routes';
import { errorMiddleware } from './middleware/error.middleware';
import { authLimiter } from './middleware/rate-limit.middleware';

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(cookieParser());

// Routes with rate limiting
app.use('/api/auth', authLimiter, authRouter);
app.use('/api/repos', repoRouter);
app.use('/api/analysis', analysisRouter);

// Error handling
app.use(errorMiddleware);

// Export app for testing
export default app;



================================================
File: server/src/index-simple.ts
================================================
import express, { Request, Response } from 'express';
import cors from 'cors';
import { v4 as uuidv4 } from 'uuid';
import bodyParser from 'body-parser';
import path from 'path';
import InMemoryStore, { Repository, Analysis } from './services/in-memory-store';
import axios from 'axios';
import jwt from 'jsonwebtoken';

// Initialize the express application
const app = express();
const port = process.env.PORT || 3030;
const store = InMemoryStore.getInstance();

// In-memory storage for user sessions
const userSessions = new Map<string, any>();

// Middleware
app.use(cors({
  origin: ['http://localhost:3001', 'http://127.0.0.1:3001'],
  credentials: true
}));
app.use(bodyParser.json());
app.use(express.static(path.join(__dirname, 'public')));

// Basic health check endpoint
app.get('/api/health', (_req: Request, res: Response) => {
  return res.json({ status: 'healthy', message: 'Server is running in simplified mode with in-memory storage' });
});

// GitHub OAuth routes
app.get('/api/auth/github', (_req: Request, res: Response) => {
  const clientId = process.env.GITHUB_CLIENT_ID;
  const redirectUri = process.env.GITHUB_CALLBACK_URL;
  const scope = 'repo read:user user:email';
  
  const githubAuthUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scope}`;
  res.redirect(githubAuthUrl);
});

app.get('/api/auth/github/callback', async (req: Request, res: Response) => {
  const { code } = req.query as { code: string };
  if (!code) {
    return res.redirect(`http://localhost:3001/login?error=missing_code`);
  }

  try {
    // Exchange code for access token
    const tokenResponse = await axios.post('https://github.com/login/oauth/access_token', {
      client_id: process.env.GITHUB_CLIENT_ID,
      client_secret: process.env.GITHUB_CLIENT_SECRET,
      code,
    }, {
      headers: {
        'Accept': 'application/json'
      }
    });

    const tokenData = tokenResponse.data;
    if (tokenData.error) {
      return res.redirect(`http://localhost:3001/login?error=${tokenData.error}`);
    }

    // Get user data from GitHub
    const userResponse = await axios.get('https://api.github.com/user', {
      headers: {
        'Authorization': `Bearer ${tokenData.access_token}`
      }
    });

    const userData = userResponse.data;
    if (!userData) {
      return res.redirect(`http://localhost:3001/login?error=github_api_error`);
    }

    // Create session
    const sessionId = Math.random().toString(36).substring(2);
    userSessions.set(sessionId, {
      id: userData.id,
      username: userData.login,
      email: userData.email,
      name: userData.name,
      avatarUrl: userData.avatar_url,
      accessToken: tokenData.access_token,
    });

    // Create JWT
    const token = jwt.sign(
      { sessionId },
      process.env.JWT_SECRET || 'default-secret',
      { expiresIn: '7d' }
    );

    // Redirect back to the client with the token
    return res.redirect(`http://localhost:3001/auth/callback?token=${token}`);
  } catch (error) {
    console.error('Authentication error:', error);
    return res.redirect(`http://localhost:3001/login?error=server_error`);
  }
});

app.get('/api/auth/profile', async (req: Request, res: Response) => {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'No token provided' });
  }

  const token = authHeader.split(' ')[1];
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as { sessionId: string };
    const sessionId = decoded.sessionId;
    
    const userData = userSessions.get(sessionId);
    if (!userData) {
      return res.status(401).json({ error: 'Invalid session' });
    }
    
    return res.json({
      status: 'success',
      data: {
        id: userData.id,
        login: userData.username,
        name: userData.name,
        email: userData.email,
        avatarUrl: userData.avatarUrl,
      },
    });
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
});

// Authentication endpoints
app.get('/api/auth/me', (req: Request, res: Response) => {
  const authHeader = req.headers.authorization;
  
  if (!authHeader || !authHeader.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Unauthorized' });
  }
  
  // In a real app, we would validate the token
  // For our simplified version, we'll just return the demo user
  const demoUser = store.getUsers()[0];
  
  if (!demoUser) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  // Convert to API response format
  const user = {
    id: demoUser.id,
    login: demoUser.username,
    name: demoUser.name || demoUser.username,
    email: demoUser.email,
    avatarUrl: demoUser.avatarUrl
  };
  
  return res.json({ user });
});

// Repository endpoints
app.get('/api/repositories', (_req: Request, res: Response) => {
  // In a real app, we'd get the user ID from the authenticated request
  const userId = store.getUsers()[0].id;
  const repositories = store.getRepositories(userId);
  
  return res.json({ repositories });
});

app.get('/api/repositories/:owner/:name', (req: Request, res: Response) => {
  const { owner, name } = req.params;
  const userId = store.getUsers()[0].id;
  
  const repository = store.getRepositoryByOwnerAndName(userId, owner, name);
  
  if (!repository) {
    return res.status(404).json({ error: 'Repository not found' });
  }
  
  return res.json({ repository });
});

app.post('/api/repositories', (req: Request, res: Response) => {
  const { owner, name } = req.body;
  
  if (!owner || !name) {
    return res.status(400).json({ error: 'Owner and name are required' });
  }
  
  const userId = store.getUsers()[0].id;
  
  // Check if repository already exists
  const existingRepo = store.getRepositoryByOwnerAndName(userId, owner, name);
  
  if (existingRepo) {
    return res.status(409).json({ error: 'Repository already exists' });
  }
  
  // Create new repository
  const newRepo: Repository = {
    id: `repo-${uuidv4()}`,
    userId,
    owner,
    name,
    description: `${name} repository`,
    url: `https://github.com/${owner}/${name}`,
    language: 'JavaScript',
    stargazersCount: Math.floor(Math.random() * 1000),
    forksCount: Math.floor(Math.random() * 200),
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  const repository = store.createRepository(newRepo);
  return res.status(201).json({ repository });
});

// New endpoint to ingest public GitHub repositories without login
app.post('/api/public-repositories', async (req: Request, res: Response) => {
  const { owner, name, url } = req.body;
  
  let repoOwner = owner;
  let repoName = name;
  
  // If URL is provided, parse owner and name from it
  if (url && (!owner || !name)) {
    try {
      const githubUrlPattern = /github\.com\/([^\/]+)\/([^\/]+)/;
      const match = url.match(githubUrlPattern);
      
      if (!match) {
        return res.status(400).json({ error: 'Invalid GitHub URL format' });
      }
      
      repoOwner = match[1];
      repoName = match[2].replace('.git', ''); // Remove .git if present
    } catch (error) {
      return res.status(400).json({ error: 'Could not parse GitHub URL' });
    }
  }
  
  if (!repoOwner || !repoName) {
    return res.status(400).json({ error: 'Repository owner and name are required' });
  }
  
  try {
    // Check if the repository exists on GitHub
    const githubResponse = await axios.get(`https://api.github.com/repos/${repoOwner}/${repoName}`);
    const repoData = githubResponse.data;
    
    if (!repoData) {
      return res.status(404).json({ error: 'Repository not found on GitHub' });
    }
    
    // Use our demo user ID for simplicity in this simplified version
    const userId = store.getUsers()[0].id;
    
    // Check if repository already exists in our system
    const existingRepo = store.getRepositoryByOwnerAndName(userId, repoOwner, repoName);
    
    if (existingRepo) {
      return res.status(200).json({ repository: existingRepo, message: 'Repository already exists' });
    }
    
    // Create new repository with data from GitHub API
    const newRepo: Repository = {
      id: `repo-${uuidv4()}`,
      userId,
      owner: repoOwner,
      name: repoName,
      description: repoData.description || `${repoName} repository`,
      url: repoData.html_url,
      language: repoData.language || 'Unknown',
      stargazersCount: repoData.stargazers_count || 0,
      forksCount: repoData.forks_count || 0,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const repository = store.createRepository(newRepo);
    
    // For simplicity, we'll trigger an analysis right away
    const newAnalysis: Analysis = {
      id: `analysis-${uuidv4()}`,
      repositoryId: repository.id,
      userId,
      status: 'pending',
      startedAt: new Date(),
      completedAt: null,
      insights: [],
      vulnerabilities: [],
      specification: null,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const analysis = store.createAnalysis(newAnalysis);
    
    // Simulate analysis completion after 5 seconds
    setTimeout(() => {
      const updatedAnalysis: Partial<Analysis> = {
        status: 'completed',
        completedAt: new Date(),
        insights: [
          {
            id: `insight-${uuidv4()}`,
            title: 'Good code organization',
            description: `The ${repository.name} codebase has a clear structure with separate concerns.`,
            severity: 'low',
            category: 'best_practice'
          },
          {
            id: `insight-${uuidv4()}`,
            title: 'Missing test coverage',
            description: 'Some critical components lack proper test coverage.',
            severity: 'medium',
            category: 'testing'
          }
        ],
        vulnerabilities: [
          {
            id: `vuln-${uuidv4()}`,
            title: 'Potential dependency vulnerability',
            description: 'The application uses outdated dependencies with known security issues.',
            severity: 'high',
            recommendation: 'Update dependencies to the latest versions.',
            location: 'package.json'
          }
        ],
        specification: {
          overview: `${repository.name} is a ${repository.language} project hosted by ${repository.owner}.`,
          components: [
            {
              name: 'Frontend',
              description: 'User interface components',
              responsibilities: ['Rendering', 'State management', 'User interactions']
            },
            {
              name: 'Backend',
              description: 'Server-side logic',
              responsibilities: ['API endpoints', 'Business logic', 'Data access']
            }
          ]
        },
        updatedAt: new Date()
      };
      
      store.updateAnalysis(analysis.id, updatedAnalysis);
      console.log(`Analysis ${analysis.id} for public repository ${repository.owner}/${repository.name} completed`);
    }, 5000);
    
    return res.status(201).json({ 
      repository, 
      analysisId: analysis.id,
      message: 'Repository ingested successfully and analysis initiated'
    });
    
  } catch (error) {
    console.error('Error ingesting public repository:', error);
    return res.status(500).json({ 
      error: 'Failed to ingest repository', 
      details: error instanceof Error ? error.message : 'Unknown error'
    });
  }
});

// Analysis endpoints
app.get('/api/repositories/:repositoryId/analyses', (req: Request, res: Response) => {
  const { repositoryId } = req.params;
  const analyses = store.getAnalyses(repositoryId);
  
  return res.json({ analyses });
});

app.get('/api/analyses/:id', (req: Request, res: Response) => {
  const { id } = req.params;
  const analysis = store.getAnalysisById(id);
  
  if (!analysis) {
    return res.status(404).json({ error: 'Analysis not found' });
  }
  
  return res.json({ analysis });
});

app.post('/api/repositories/:repositoryId/analyses', (req: Request, res: Response) => {
  const { repositoryId } = req.params;
  const repository = store.getRepositoryById(repositoryId);
  
  if (!repository) {
    return res.status(404).json({ error: 'Repository not found' });
  }
  
  const userId = store.getUsers()[0].id;
  
  // Create a new analysis with pending status
  const newAnalysis: Analysis = {
    id: `analysis-${uuidv4()}`,
    repositoryId,
    userId,
    status: 'pending',
    startedAt: new Date(),
    completedAt: null,
    insights: [],
    vulnerabilities: [],
    specification: null,
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  const analysis = store.createAnalysis(newAnalysis);
  
  // In a real app, we would start the analysis process asynchronously
  // For our simplified version, we'll just return the created analysis
  res.status(201).json({ analysis });
  
  // Simulate analysis completion after 5 seconds
  setTimeout(() => {
    const updatedAnalysis: Partial<Analysis> = {
      status: 'completed',
      completedAt: new Date(),
      insights: [
        {
          id: `insight-${uuidv4()}`,
          title: 'Good code organization',
          description: 'The codebase has a clear structure with separate concerns.',
          severity: 'low',
          category: 'best_practice'
        },
        {
          id: `insight-${uuidv4()}`,
          title: 'Missing test coverage',
          description: 'Some critical components lack proper test coverage.',
          severity: 'medium',
          category: 'testing'
        }
      ],
      vulnerabilities: [
        {
          id: `vuln-${uuidv4()}`,
          title: 'Potential dependency vulnerability',
          description: 'The application uses outdated dependencies with known security issues.',
          severity: 'high',
          recommendation: 'Update dependencies to the latest versions.',
          location: 'package.json'
        }
      ],
      specification: {
        overview: `${repository.name} is a ${repository.language} project with standard architecture.`,
        components: [
          {
            name: 'Frontend',
            description: 'User interface components',
            responsibilities: ['Rendering', 'State management', 'User interactions']
          },
          {
            name: 'Backend',
            description: 'Server-side logic',
            responsibilities: ['API endpoints', 'Business logic', 'Data access']
          }
        ]
      },
      updatedAt: new Date()
    };
    
    store.updateAnalysis(analysis.id, updatedAnalysis);
    console.log(`Analysis ${analysis.id} completed`);
  }, 5000);
  
  return;
});

// Start the server
app.listen(port, () => {
  console.log(`Server running on port ${port} in simplified mode with in-memory storage`);
  console.log(`Health check available at http://localhost:${port}/api/health`);
});

export default app;



================================================
File: server/src/index.ts
================================================
import app from './app';

const port = process.env.PORT || 3000;

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
  console.log('Environment:', process.env.NODE_ENV || 'development');
  console.log('GitHub OAuth:', process.env.GITHUB_CLIENT_ID ? 'Configured' : 'Not configured');
  console.log('Claude API:', process.env.CLAUDE_API_KEY ? 'Configured' : 'Not configured');
});



================================================
File: server/src/config/database.ts
================================================
import mongoose from 'mongoose';
import { createClient } from 'redis';
import env from './env';
import logger from './logger';

export async function connectToMongoDB(): Promise<void> {
  try {
    await mongoose.connect(env.MONGODB_URI);
    logger.info('Connected to MongoDB successfully');
  } catch (error) {
    logger.error('Failed to connect to MongoDB:', error);
    process.exit(1);
  }
}

export async function connectToRedis() {
  const client = createClient({
    url: env.REDIS_URL,
  });

  client.on('error', (error) => {
    logger.error('Redis Client Error:', error);
  });

  client.on('connect', () => {
    logger.info('Connected to Redis successfully');
  });

  await client.connect();
  return client;
}

// Graceful shutdown
export function setupGracefulShutdown() {
  const shutdown = async () => {
    logger.info('Initiating graceful shutdown...');
    
    try {
      await mongoose.disconnect();
      logger.info('MongoDB disconnected');
      
      const redis = await connectToRedis();
      await redis.quit();
      logger.info('Redis disconnected');
      
      process.exit(0);
    } catch (error) {
      logger.error('Error during graceful shutdown:', error);
      process.exit(1);
    }
  };

  process.on('SIGTERM', shutdown);
  process.on('SIGINT', shutdown);
}



================================================
File: server/src/config/env.ts
================================================
import { z } from 'zod';
import dotenv from 'dotenv';

// Load environment variables from .env file
dotenv.config();

// Define the environment variables schema
const envSchema = z.object({
  NODE_ENV: z.enum(['development', 'production', 'test']).default('development'),
  PORT: z.coerce.number().default(3000),
  MONGODB_URI: z.string().url(),
  REDIS_URL: z.string().url(),
  JWT_SECRET: z.string().min(32),
  JWT_EXPIRES_IN: z.string().default('1d'),
  GITHUB_CLIENT_ID: z.string(),
  GITHUB_CLIENT_SECRET: z.string(),
  GITHUB_CALLBACK_URL: z.string().url(),
  ANTHROPIC_API_KEY: z.string(),
  CLAUDE_API_KEY: z.string(),
  RATE_LIMIT_WINDOW_MS: z.coerce.number().default(60000),
  RATE_LIMIT_MAX_REQUESTS: z.coerce.number().default(100),
});

// Parse and validate environment variables
const env = envSchema.parse({
  NODE_ENV: process.env.NODE_ENV,
  PORT: process.env.PORT,
  MONGODB_URI: process.env.MONGODB_URI,
  REDIS_URL: process.env.REDIS_URL,
  JWT_SECRET: process.env.JWT_SECRET,
  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN,
  GITHUB_CLIENT_ID: process.env.GITHUB_CLIENT_ID,
  GITHUB_CLIENT_SECRET: process.env.GITHUB_CLIENT_SECRET,
  GITHUB_CALLBACK_URL: process.env.GITHUB_CALLBACK_URL,
  ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
  CLAUDE_API_KEY: process.env.CLAUDE_API_KEY,
  RATE_LIMIT_WINDOW_MS: process.env.RATE_LIMIT_WINDOW_MS,
  RATE_LIMIT_MAX_REQUESTS: process.env.RATE_LIMIT_MAX_REQUESTS,
});

export default env;



================================================
File: server/src/config/logger.ts
================================================
import winston from 'winston';
import env from './env';

const logger = winston.createLogger({
  level: env.NODE_ENV === 'development' ? 'debug' : 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { service: 'codeinsight-server' },
  transports: [
    // Write all logs to console
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
  ],
});

// Add file transport in production
if (env.NODE_ENV === 'production') {
  logger.add(
    new winston.transports.File({
      filename: 'logs/error.log',
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
  logger.add(
    new winston.transports.File({
      filename: 'logs/combined.log',
      maxsize: 5242880, // 5MB
      maxFiles: 5,
    })
  );
}

export default logger;



================================================
File: server/src/middleware/auth.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { ApiException } from '@codeinsight/common';
import env from '../config/env';
import { UserModel } from '../models/user.model';

// Extend Express Request type to include user
declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        githubId: number;
        username: string;
      };
    }
  }
}

export async function authenticate(
  req: Request,
  res: Response,
  next: NextFunction
) {
  try {
    const token = extractToken(req);
    if (!token) {
      throw new ApiException('UNAUTHORIZED', 'Authentication required');
    }

    const decoded = jwt.verify(token, env.JWT_SECRET) as {
      id: string;
      githubId: number;
      username: string;
    };

    // Verify user exists in database
    const user = await UserModel.findById(decoded.id);
    if (!user) {
      throw new ApiException('UNAUTHORIZED', 'User not found');
    }

    // Attach user to request
    req.user = {
      id: user._id.toString(),
      githubId: user.githubId,
      username: user.username,
    };

    next();
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      next(new ApiException('UNAUTHORIZED', 'Invalid token'));
    } else {
      next(error);
    }
  }
}

function extractToken(req: Request): string | null {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    return null;
  }
  return authHeader.split(' ')[1];
}



================================================
File: server/src/middleware/error.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export const errorMiddleware = (
  error: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
) => {
  if (error instanceof ApiError) {
    return res.status(error.statusCode).json({
      status: 'error',
      message: error.message,
    });
  }

  // Log unexpected errors
  console.error('Unexpected error:', error);

  return res.status(500).json({
    status: 'error',
    message: 'Internal server error',
  });
};



================================================
File: server/src/middleware/rate-limit.middleware.ts
================================================
import rateLimit from 'express-rate-limit';
import { Request, Response } from 'express';
import { ApiError } from './error.middleware';

// Default rate limit configuration
const defaultConfig = {
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
  handler: (_req: Request, _res: Response) => {
    throw new ApiError(429, 'Too many requests from this IP, please try again later');
  },
};

// More restrictive limit for authentication routes
export const authLimiter = rateLimit({
  ...defaultConfig,
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 5, // Limit each IP to 5 login attempts per hour
  message: 'Too many login attempts from this IP, please try again after an hour',
  handler: (_req: Request, _res: Response) => {
    throw new ApiError(429, 'Too many login attempts from this IP, please try again after an hour');
  },
});



================================================
File: server/src/models/analysis.model.ts
================================================
import { Schema, model, Document } from 'mongoose';

export type AnalysisStatus = 'pending' | 'processing' | 'completed' | 'failed';

interface IAnalysis {
  userId: Schema.Types.ObjectId;
  repositoryId: Schema.Types.ObjectId;
  status: AnalysisStatus;
  insights: Array<{
    type: string;
    content: string;
    path?: string;
    severity?: 'info' | 'warning' | 'error';
  }>;
  vulnerabilities: Array<{
    type: string;
    description: string;
    path?: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    recommendation?: string;
  }>;
  specifications: {
    overview?: string;
    architecture?: string;
    dependencies?: string;
    setup?: string;
  };
  createdAt: Date;
  updatedAt: Date;
}

export interface AnalysisDocument extends IAnalysis, Document {}

const analysisSchema = new Schema<AnalysisDocument>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    repositoryId: {
      type: Schema.Types.ObjectId,
      ref: 'Repository',
      required: true,
    },
    status: {
      type: String,
      enum: ['pending', 'processing', 'completed', 'failed'],
      default: 'pending',
      required: true,
    },
    insights: [
      {
        type: {
          type: String,
          required: true,
        },
        content: {
          type: String,
          required: true,
        },
        path: String,
        severity: {
          type: String,
          enum: ['info', 'warning', 'error'],
        },
      },
    ],
    vulnerabilities: [
      {
        type: {
          type: String,
          required: true,
        },
        description: {
          type: String,
          required: true,
        },
        path: String,
        severity: {
          type: String,
          enum: ['low', 'medium', 'high', 'critical'],
          required: true,
        },
        recommendation: String,
      },
    ],
    specifications: {
      overview: String,
      architecture: String,
      dependencies: String,
      setup: String,
    },
  },
  {
    timestamps: true,
  }
);

// Create indexes for frequently queried fields
analysisSchema.index({ userId: 1, repositoryId: 1 });
analysisSchema.index({ status: 1 });
analysisSchema.index({ createdAt: -1 });

export const Analysis = model<AnalysisDocument>('Analysis', analysisSchema);



================================================
File: server/src/models/repository.model.ts
================================================
import { Schema, model, Document, Types } from 'mongoose';

interface IRepository {
  userId: Types.ObjectId;
  name: string;
  owner: string;
  url: string;
  branch: string;
  private: boolean;
  description?: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface RepositoryDocument extends IRepository, Document {}

const repositorySchema = new Schema<RepositoryDocument>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    name: {
      type: String,
      required: true,
    },
    owner: {
      type: String,
      required: true,
    },
    url: {
      type: String,
      required: true,
    },
    branch: {
      type: String,
      required: true,
      default: 'main',
    },
    private: {
      type: Boolean,
      required: true,
      default: false,
    },
    description: {
      type: String,
    },
  },
  {
    timestamps: true,
  }
);

// Create a compound index for owner and name to ensure uniqueness
repositorySchema.index({ owner: 1, name: 1 }, { unique: true });

export const Repository = model<RepositoryDocument>('Repository', repositorySchema);



================================================
File: server/src/models/user.model.ts
================================================
import { Schema, model, Document } from 'mongoose';

interface IUser {
  githubId: number;
  username: string;
  email: string;
  name?: string;
  avatarUrl: string;
  accessToken: string;
  createdAt: Date;
  updatedAt: Date;
}

// Extend the IUser type with mongoose Document
export interface UserDocument extends IUser, Document {}

const userSchema = new Schema<UserDocument>(
  {
    githubId: {
      type: Number,
      required: true,
      unique: true,
    },
    username: {
      type: String,
      required: true,
      unique: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
    },
    name: {
      type: String,
    },
    avatarUrl: {
      type: String,
      required: true,
    },
    accessToken: {
      type: String,
      required: true,
      select: false, // Don't include in query results by default
    },
  },
  {
    timestamps: true,
    toJSON: {
      transform: (_, ret) => {
        delete ret.__v;
        delete ret.accessToken;
        return ret;
      },
    },
  }
);

// Create indexes for frequently queried fields
userSchema.index({ githubId: 1 });
userSchema.index({ email: 1 });
userSchema.index({ username: 1 });

export const User = model<UserDocument>('User', userSchema);



================================================
File: server/src/routes/analysis.routes.ts
================================================
import { Router } from 'express';
import { ApiError } from '../middleware/error.middleware';
import { claudeService } from '../services/claude.service';

const router = Router();

// In-memory storage for analysis results
const analysisResults = new Map<string, any>();

router.post('/:owner/:repo', async (req, res) => {
  const { owner, repo } = req.params;
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    throw new ApiError(401, 'No token provided');
  }

  const token = authHeader.split(' ')[1];

  try {
    // Get repository contents from GitHub
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents`,
      {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      throw new ApiError(response.status, 'Failed to fetch repository contents');
    }

    const contents = await response.json();
    const files = contents.filter((item: any) => item.type === 'file');

    // Analyze each file
    const analysisPromises = files.map(async (file: any) => {
      const fileResponse = await fetch(file.download_url);
      const content = await fileResponse.text();
      return {
        file: file.path,
        analysis: await claudeService.analyzeCodeStructured(content),
      };
    });

    const analysis = await Promise.all(analysisPromises);
    const analysisId = Math.random().toString(36).substring(2);
    
    analysisResults.set(analysisId, {
      id: analysisId,
      repository: `${owner}/${repo}`,
      timestamp: new Date().toISOString(),
      results: analysis,
    });

    res.json({
      status: 'success',
      data: {
        id: analysisId,
        repository: `${owner}/${repo}`,
        results: analysis,
      },
    });
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, 'Analysis failed');
  }
});

router.get('/:id', (req, res) => {
  const { id } = req.params;
  const analysis = analysisResults.get(id);

  if (!analysis) {
    throw new ApiError(404, 'Analysis not found');
  }

  res.json({
    status: 'success',
    data: analysis,
  });
});

router.get('/', (_req, res) => {
  const analyses = Array.from(analysisResults.values());
  res.json({
    status: 'success',
    data: analyses,
  });
});

export const analysisRouter = router;



================================================
File: server/src/routes/auth.routes.ts
================================================
import { Router } from 'express';
import jwt from 'jsonwebtoken';
import { ApiError } from '../middleware/error.middleware';

const router = Router();

// In-memory storage for user sessions
const userSessions = new Map<string, any>();

router.get('/github', (_req, res) => {
  const clientId = process.env.GITHUB_CLIENT_ID;
  const redirectUri = process.env.GITHUB_CALLBACK_URL;
  const scope = 'repo read:user user:email';
  
  const githubAuthUrl = `https://github.com/login/oauth/authorize?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scope}`;
  res.redirect(githubAuthUrl);
});

router.get('/github/callback', async (req, res) => {
  const { code } = req.query as { code: string };
  if (!code) {
    return res.redirect(`${process.env.REACT_APP_CLIENT_URL || 'http://localhost:3001'}/login?error=missing_code`);
  }

  try {
    // Exchange code for access token
    const tokenResponse = await fetch('https://github.com/login/oauth/access_token', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Accept: 'application/json',
      },
      body: JSON.stringify({
        client_id: process.env.GITHUB_CLIENT_ID,
        client_secret: process.env.GITHUB_CLIENT_SECRET,
        code,
      }),
    });

    const tokenData = await tokenResponse.json();
    if (tokenData.error) {
      return res.redirect(`${process.env.REACT_APP_CLIENT_URL || 'http://localhost:3001'}/login?error=${tokenData.error}`);
    }

    // Get user data from GitHub
    const userResponse = await fetch('https://api.github.com/user', {
      headers: {
        Authorization: `Bearer ${tokenData.access_token}`,
      },
    });

    const userData = await userResponse.json();
    if (userResponse.status !== 200) {
      return res.redirect(`${process.env.REACT_APP_CLIENT_URL || 'http://localhost:3001'}/login?error=github_api_error`);
    }

    // Create session
    const sessionId = Math.random().toString(36).substring(2);
    userSessions.set(sessionId, {
      id: userData.id,
      username: userData.login,
      email: userData.email,
      name: userData.name,
      avatarUrl: userData.avatar_url,
      accessToken: tokenData.access_token,
    });

    // Create JWT
    const token = jwt.sign(
      { sessionId },
      process.env.JWT_SECRET || 'default-secret',
      { expiresIn: '7d', algorithm: 'HS256' }
    );

    // Redirect back to the client with the token
    return res.redirect(`${process.env.REACT_APP_CLIENT_URL || 'http://localhost:3001'}/auth/callback?token=${token}`);
  } catch (error) {
    console.error('Authentication error:', error);
    return res.redirect(`${process.env.REACT_APP_CLIENT_URL || 'http://localhost:3001'}/login?error=server_error`);
  }
});

router.get('/profile', async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    throw new ApiError(401, 'No token provided');
  }

  const token = authHeader.split(' ')[1];
  
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'default-secret') as { sessionId: string };
    const sessionId = decoded.sessionId;
    
    const userData = userSessions.get(sessionId);
    if (!userData) {
      throw new ApiError(401, 'Invalid session');
    }
    
    return res.json({
      status: 'success',
      data: {
        id: userData.id,
        login: userData.username,
        name: userData.name,
        email: userData.email,
        avatarUrl: userData.avatarUrl,
      },
    });
  } catch (error) {
    if (error instanceof jwt.JsonWebTokenError) {
      throw new ApiError(401, 'Invalid token');
    }
    throw error;
  }
});

export const authRouter = router;



================================================
File: server/src/routes/repo.routes.ts
================================================
import { Router } from 'express';
import { ApiError } from '../middleware/error.middleware';

const router = Router();

router.get('/', async (req, res) => {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    throw new ApiError(401, 'No token provided');
  }

  const token = authHeader.split(' ')[1];

  try {
    // Get user's repositories from GitHub
    const response = await fetch('https://api.github.com/user/repos', {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github.v3+json',
      },
    });

    if (!response.ok) {
      throw new ApiError(response.status, 'Failed to fetch repositories');
    }

    const repos = await response.json();
    const repoList = repos.map((repo: any) => ({
      id: repo.id,
      name: repo.name,
      fullName: repo.full_name,
      description: repo.description,
      private: repo.private,
      url: repo.html_url,
      defaultBranch: repo.default_branch,
      stars: repo.stargazers_count,
      language: repo.language,
    }));

    res.json({
      status: 'success',
      data: repoList,
    });
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, 'Failed to fetch repositories');
  }
});

router.get('/:owner/:repo', async (req, res) => {
  const { owner, repo } = req.params;
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    throw new ApiError(401, 'No token provided');
  }

  const token = authHeader.split(' ')[1];

  try {
    // Get repository details from GitHub
    const response = await fetch(`https://api.github.com/repos/${owner}/${repo}`, {
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github.v3+json',
      },
    });

    if (!response.ok) {
      throw new ApiError(response.status, 'Failed to fetch repository');
    }

    const repoData = await response.json();
    const repository = {
      id: repoData.id,
      name: repoData.name,
      fullName: repoData.full_name,
      description: repoData.description,
      private: repoData.private,
      url: repoData.html_url,
      defaultBranch: repoData.default_branch,
      stars: repoData.stargazers_count,
      language: repoData.language,
      size: repoData.size,
      createdAt: repoData.created_at,
      updatedAt: repoData.updated_at,
    };

    res.json({
      status: 'success',
      data: repository,
    });
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, 'Failed to fetch repository');
  }
});

router.get('/:owner/:repo/contents', async (req, res) => {
  const { owner, repo } = req.params;
  const { path = '' } = req.query;
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith('Bearer ')) {
    throw new ApiError(401, 'No token provided');
  }

  const token = authHeader.split(' ')[1];

  try {
    // Get repository contents from GitHub
    const response = await fetch(
      `https://api.github.com/repos/${owner}/${repo}/contents/${path}`,
      {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/vnd.github.v3+json',
        },
      }
    );

    if (!response.ok) {
      throw new ApiError(response.status, 'Failed to fetch repository contents');
    }

    const contents = await response.json();
    res.json({
      status: 'success',
      data: Array.isArray(contents)
        ? contents.map((item: any) => ({
            name: item.name,
            path: item.path,
            type: item.type,
            size: item.size,
            url: item.html_url,
            downloadUrl: item.download_url,
          }))
        : {
            name: contents.name,
            path: contents.path,
            type: contents.type,
            size: contents.size,
            url: contents.html_url,
            downloadUrl: contents.download_url,
            content: contents.content
              ? Buffer.from(contents.content, 'base64').toString('utf-8')
              : null,
          },
    });
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    throw new ApiError(500, 'Failed to fetch repository contents');
  }
});

export const repoRouter = router;



================================================
File: server/src/routes/repository.routes.ts
================================================
import { Router } from 'express';
import { z } from 'zod';
import { authenticate } from '../middleware/auth.middleware';
import { apiLimiter } from '../middleware/rate-limit.middleware';
import { RepositoryService } from '../services/repository.service';
import { CacheService } from '../services/cache.service';

const router = Router();
const repositoryService = new RepositoryService();
const cacheService = CacheService.getInstance();

// Validation schemas
const addRepositorySchema = z.object({
  owner: z.string(),
  name: z.string(),
});

const paginationSchema = z.object({
  page: z.string().transform(Number).default('1'),
  limit: z.string().transform(Number).default('10'),
});

const contentQuerySchema = z.object({
  path: z.string().default(''),
  ref: z.string().optional(),
});

// Add repository
router.post('/', authenticate, apiLimiter, async (req, res, next) => {
  try {
    const { owner, name } = addRepositorySchema.parse(req.body);
    const repository = await repositoryService.addRepository(
      req.user!.id,
      owner,
      name
    );

    // Clear user's repository cache
    await cacheService.delete(`user:${req.user!.id}:repos`);

    res.status(201).json(repository);
  } catch (error) {
    next(error);
  }
});

// List user repositories
router.get('/', authenticate, apiLimiter, async (req, res, next) => {
  try {
    const { page, limit } = paginationSchema.parse(req.query);

    // Try to get from cache
    const cacheKey = `user:${req.user!.id}:repos:${page}:${limit}`;
    const cachedRepos = await cacheService.get(cacheKey);
    if (cachedRepos) {
      return res.json(cachedRepos);
    }

    const result = await repositoryService.getUserRepositories(
      req.user!.id,
      page,
      limit
    );

    // Cache for 5 minutes
    await cacheService.set(cacheKey, result, 300);

    res.json(result);
  } catch (error) {
    next(error);
  }
});

// Get repository by ID
router.get('/:id', authenticate, apiLimiter, async (req, res, next) => {
  try {
    const repository = await repositoryService.getRepository(
      req.user!.id,
      req.params.id
    );
    res.json(repository);
  } catch (error) {
    next(error);
  }
});

// Get repository content
router.get('/:id/content', authenticate, apiLimiter, async (req, res, next) => {
  try {
    const { path, ref } = contentQuerySchema.parse(req.query);
    
    // Try to get from cache
    const cacheKey = `repo:${req.params.id}:content:${path}:${ref || 'default'}`;
    const cachedContent = await cacheService.get(cacheKey);
    if (cachedContent) {
      return res.json(cachedContent);
    }

    const content = await repositoryService.listRepositoryContent(
      req.user!.id,
      req.params.id,
      path,
      ref
    );

    // Cache for 5 minutes
    await cacheService.set(cacheKey, content, 300);

    res.json(content);
  } catch (error) {
    next(error);
  }
});

// Sync repository with GitHub
router.post('/:id/sync', authenticate, apiLimiter, async (req, res, next) => {
  try {
    const repository = await repositoryService.syncWithGitHub(
      req.user!.id,
      req.params.id
    );

    // Clear repository caches
    const cacheKeys = [
      `repo:${req.params.id}`,
      `user:${req.user!.id}:repos`,
    ];
    await Promise.all(cacheKeys.map((key) => cacheService.delete(key)));

    res.json(repository);
  } catch (error) {
    next(error);
  }
});

// Remove repository
router.delete('/:id', authenticate, apiLimiter, async (req, res, next) => {
  try {
    await repositoryService.removeRepository(req.user!.id, req.params.id);

    // Clear repository caches
    const cacheKeys = [
      `repo:${req.params.id}`,
      `user:${req.user!.id}:repos`,
    ];
    await Promise.all(cacheKeys.map((key) => cacheService.delete(key)));

    res.status(204).send();
  } catch (error) {
    next(error);
  }
});

export default router;



================================================
File: server/src/services/analysis.service.ts
================================================
import { ApiException } from '@codeinsight/common';
import { AnalysisModel } from '../models/analysis.model';
import { RepositoryService } from './repository.service';
import { ClaudeService } from './claude.service';
import logger from '../config/logger';

export class AnalysisService {
  private repositoryService: RepositoryService;
  private claudeService: ClaudeService;

  constructor() {
    this.repositoryService = new RepositoryService();
    this.claudeService = new ClaudeService();
  }

  async startAnalysis(userId: string, repoId: string) {
    try {
      // Get repository details
      const repository = await this.repositoryService.getRepository(userId, repoId);

      // Create initial analysis record
      const analysis = await AnalysisModel.create({
        userId,
        repositoryId: repoId,
        status: 'pending',
        specifications: {
          overview: '',
          architecture: '',
          components: [],
        },
      });

      // Start analysis process asynchronously
      this.processAnalysis(analysis._id.toString(), userId, repository).catch(
        (error) => {
          logger.error('Analysis processing error:', error);
        }
      );

      return analysis;
    } catch (error) {
      logger.error('Failed to start analysis:', error);
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to start analysis'
      );
    }
  }

  private async processAnalysis(analysisId: string, userId: string, repository: any) {
    try {
      // Update status to processing
      await AnalysisModel.findByIdAndUpdate(analysisId, {
        status: 'processing',
      });

      // Get repository content
      const files = await this.getRepositoryFiles(userId, repository._id);

      // Generate project specification
      const specifications = await this.claudeService.generateSpecification(
        files,
        {
          repoName: repository.name,
          owner: repository.owner,
          description: repository.description,
        }
      );

      // Analyze each file
      const analysisResults = await Promise.all(
        files.map((file) =>
          this.claudeService.analyzeCode(file.content, {
            repoName: repository.name,
            owner: repository.owner,
            path: file.path,
            language: this.detectLanguage(file.path),
          })
        )
      );

      // Combine all insights and vulnerabilities
      const combinedResults = analysisResults.reduce(
        (acc, result) => ({
          insights: [...acc.insights, ...result.insights],
          vulnerabilities: [...acc.vulnerabilities, ...result.vulnerabilities],
        }),
        { insights: [], vulnerabilities: [] }
      );

      // Update analysis with results
      await AnalysisModel.findByIdAndUpdate(analysisId, {
        status: 'completed',
        insights: combinedResults.insights,
        vulnerabilities: combinedResults.vulnerabilities,
        specifications,
      });
    } catch (error) {
      logger.error('Analysis processing failed:', error);
      await AnalysisModel.findByIdAndUpdate(analysisId, {
        status: 'failed',
      });
    }
  }

  private async getRepositoryFiles(userId: string, repoId: string) {
    const MAX_FILE_SIZE = 100 * 1024; // 100KB
    const files: Array<{ path: string; content: string }> = [];

    async function processContent(content: any) {
      if (Array.isArray(content)) {
        for (const item of content) {
          if (item.type === 'file' && item.size <= MAX_FILE_SIZE) {
            const fileContent = await this.repositoryService.listRepositoryContent(
              userId,
              repoId,
              item.path
            );
            if ('content' in fileContent) {
              files.push({
                path: item.path,
                content: fileContent.content,
              });
            }
          } else if (item.type === 'dir') {
            const dirContent = await this.repositoryService.listRepositoryContent(
              userId,
              repoId,
              item.path
            );
            await processContent.call(this, dirContent);
          }
        }
      }
    }

    const rootContent = await this.repositoryService.listRepositoryContent(
      userId,
      repoId
    );
    await processContent.call(this, rootContent);

    return files;
  }

  private detectLanguage(filePath: string): string | undefined {
    const extensions: Record<string, string> = {
      '.js': 'JavaScript',
      '.ts': 'TypeScript',
      '.py': 'Python',
      '.java': 'Java',
      '.rb': 'Ruby',
      '.php': 'PHP',
      '.go': 'Go',
      '.rs': 'Rust',
      '.cpp': 'C++',
      '.c': 'C',
      '.cs': 'C#',
      '.html': 'HTML',
      '.css': 'CSS',
      '.scss': 'SCSS',
      '.json': 'JSON',
      '.md': 'Markdown',
      '.yaml': 'YAML',
      '.yml': 'YAML',
    };

    const ext = filePath.substring(filePath.lastIndexOf('.')).toLowerCase();
    return extensions[ext];
  }

  async getAnalysis(userId: string, analysisId: string) {
    try {
      const analysis = await AnalysisModel.findOne({
        _id: analysisId,
        userId,
      });

      if (!analysis) {
        throw new ApiException('NOT_FOUND', 'Analysis not found');
      }

      return analysis;
    } catch (error) {
      logger.error('Failed to get analysis:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to fetch analysis'
      );
    }
  }

  async listAnalyses(userId: string, page = 1, limit = 10) {
    try {
      const skip = (page - 1) * limit;

      const [analyses, total] = await Promise.all([
        AnalysisModel.find({ userId })
          .sort({ createdAt: -1 })
          .skip(skip)
          .limit(limit),
        AnalysisModel.countDocuments({ userId }),
      ]);

      return {
        analyses,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      logger.error('Failed to list analyses:', error);
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to fetch analyses'
      );
    }
  }

  async deleteAnalysis(userId: string, analysisId: string) {
    try {
      const result = await AnalysisModel.deleteOne({
        _id: analysisId,
        userId,
      });

      if (result.deletedCount === 0) {
        throw new ApiException('NOT_FOUND', 'Analysis not found');
      }

      return true;
    } catch (error) {
      logger.error('Failed to delete analysis:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to delete analysis'
      );
    }
  }
}



================================================
File: server/src/services/auth.service.ts
================================================
import jwt from 'jsonwebtoken';
import { ApiException } from '@codeinsight/common';
import { UserModel } from '../models/user.model';
import { GitHubService } from './github.service';
import env from '../config/env';
import logger from '../config/logger';

export class AuthService {
  async authenticateWithGitHub(code: string): Promise<{
    user: any;
    token: string;
  }> {
    try {
      // Exchange code for access token
      const accessToken = await this.getGitHubAccessToken(code);
      
      // Get user data from GitHub
      const githubService = new GitHubService(accessToken);
      const githubUser = await githubService.getUser();

      // Find or create user in our database
      const user = await this.findOrCreateUser({
        ...githubUser,
        accessToken,
      });

      // Generate JWT token
      const token = this.generateToken(user);

      return { user, token };
    } catch (error) {
      logger.error('Authentication Error:', error);
      throw new ApiException(
        'UNAUTHORIZED',
        'Failed to authenticate with GitHub'
      );
    }
  }

  private async getGitHubAccessToken(code: string): Promise<string> {
    const params = new URLSearchParams({
      client_id: env.GITHUB_CLIENT_ID,
      client_secret: env.GITHUB_CLIENT_SECRET,
      code,
    });

    const response = await fetch(
      'https://github.com/login/oauth/access_token',
      {
        method: 'POST',
        headers: {
          Accept: 'application/json',
        },
        body: params,
      }
    );

    if (!response.ok) {
      throw new Error('Failed to get GitHub access token');
    }

    const data = await response.json();
    if (data.error) {
      throw new Error(data.error_description || data.error);
    }

    return data.access_token;
  }

  private async findOrCreateUser(githubUser: {
    githubId: number;
    username: string;
    email: string;
    name?: string;
    avatarUrl: string;
    accessToken: string;
  }) {
    try {
      // Try to find existing user
      let user = await UserModel.findOne({ githubId: githubUser.githubId });

      if (user) {
        // Update existing user
        user.username = githubUser.username;
        user.email = githubUser.email;
        user.name = githubUser.name;
        user.avatarUrl = githubUser.avatarUrl;
        user.accessToken = githubUser.accessToken;
        await user.save();
      } else {
        // Create new user
        user = await UserModel.create(githubUser);
      }

      return user;
    } catch (error) {
      logger.error('Database Error - findOrCreateUser:', error);
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to process user data'
      );
    }
  }

  private generateToken(user: any): string {
    return jwt.sign(
      {
        id: user._id,
        githubId: user.githubId,
        username: user.username,
      },
      env.JWT_SECRET,
      {
        expiresIn: env.JWT_EXPIRES_IN,
      }
    );
  }

  async validateToken(token: string) {
    try {
      const decoded = jwt.verify(token, env.JWT_SECRET) as {
        id: string;
        githubId: number;
        username: string;
      };

      const user = await UserModel.findById(decoded.id);
      if (!user) {
        throw new Error('User not found');
      }

      return {
        id: user._id,
        githubId: user.githubId,
        username: user.username,
      };
    } catch (error) {
      throw new ApiException('UNAUTHORIZED', 'Invalid or expired token');
    }
  }

  async revokeAccess(userId: string) {
    try {
      const user = await UserModel.findById(userId);
      if (!user) {
        throw new ApiException('NOT_FOUND', 'User not found');
      }

      // Clear GitHub access token
      user.accessToken = '';
      await user.save();

      return true;
    } catch (error) {
      logger.error('Failed to revoke access:', error);
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to revoke access'
      );
    }
  }
}



================================================
File: server/src/services/cache.service.ts
================================================
import { createClient, RedisClientType } from 'redis';
import { ApiException } from '@codeinsight/common';
import env from '../config/env';
import logger from '../config/logger';

export class CacheService {
  private static instance: CacheService;
  private client: RedisClientType;
  private connected: boolean;

  private constructor() {
    this.connected = false;
    this.client = createClient({
      url: env.REDIS_URL,
    });

    this.setupEventHandlers();
  }

  public static getInstance(): CacheService {
    if (!CacheService.instance) {
      CacheService.instance = new CacheService();
    }
    return CacheService.instance;
  }

  private setupEventHandlers() {
    this.client.on('error', (error) => {
      logger.error('Redis Client Error:', error);
      this.connected = false;
    });

    this.client.on('connect', () => {
      logger.info('Connected to Redis successfully');
      this.connected = true;
    });
  }

  public async connect() {
    if (!this.connected) {
      try {
        await this.client.connect();
      } catch (error) {
        logger.error('Failed to connect to Redis:', error);
        throw new ApiException(
          'INTERNAL_SERVER_ERROR',
          'Failed to connect to cache service'
        );
      }
    }
  }

  public async disconnect() {
    if (this.connected) {
      try {
        await this.client.quit();
        this.connected = false;
      } catch (error) {
        logger.error('Failed to disconnect from Redis:', error);
      }
    }
  }

  public async get<T>(key: string): Promise<T | null> {
    try {
      const data = await this.client.get(key);
      return data ? JSON.parse(data) : null;
    } catch (error) {
      logger.error('Cache get error:', error);
      return null;
    }
  }

  public async set(key: string, value: unknown, ttlSeconds?: number): Promise<void> {
    try {
      const serialized = JSON.stringify(value);
      if (ttlSeconds) {
        await this.client.setEx(key, ttlSeconds, serialized);
      } else {
        await this.client.set(key, serialized);
      }
    } catch (error) {
      logger.error('Cache set error:', error);
    }
  }

  public async delete(key: string): Promise<void> {
    try {
      await this.client.del(key);
    } catch (error) {
      logger.error('Cache delete error:', error);
    }
  }

  public async increment(key: string): Promise<number> {
    try {
      return await this.client.incr(key);
    } catch (error) {
      logger.error('Cache increment error:', error);
      return 0;
    }
  }

  public async getRateLimit(key: string, windowSeconds: number): Promise<number> {
    try {
      const count = await this.client.get(key);
      return count ? parseInt(count, 10) : 0;
    } catch (error) {
      logger.error('Rate limit get error:', error);
      return 0;
    }
  }

  public async setRateLimit(
    key: string,
    windowSeconds: number,
    maxRequests: number
  ): Promise<boolean> {
    try {
      const count = await this.increment(key);
      if (count === 1) {
        await this.client.expire(key, windowSeconds);
      }
      return count <= maxRequests;
    } catch (error) {
      logger.error('Rate limit set error:', error);
      return false;
    }
  }

  public async clearRateLimit(key: string): Promise<void> {
    await this.delete(key);
  }

  // Analysis caching methods
  public async getCachedAnalysis(repoId: string): Promise<unknown | null> {
    return this.get(`analysis:${repoId}`);
  }

  public async setCachedAnalysis(
    repoId: string,
    analysis: unknown,
    ttlSeconds = 3600 // 1 hour default
  ): Promise<void> {
    await this.set(`analysis:${repoId}`, analysis, ttlSeconds);
  }

  // Repository content caching methods
  public async getCachedRepoContent(
    owner: string,
    repo: string,
    path: string
  ): Promise<unknown | null> {
    return this.get(`repo:${owner}:${repo}:${path}`);
  }

  public async setCachedRepoContent(
    owner: string,
    repo: string,
    path: string,
    content: unknown,
    ttlSeconds = 300 // 5 minutes default
  ): Promise<void> {
    await this.set(
      `repo:${owner}:${repo}:${path}`,
      content,
      ttlSeconds
    );
  }

  // User repository list caching
  public async getCachedUserRepos(userId: string): Promise<unknown | null> {
    return this.get(`user:${userId}:repos`);
  }

  public async setCachedUserRepos(
    userId: string,
    repos: unknown,
    ttlSeconds = 300 // 5 minutes default
  ): Promise<void> {
    await this.set(`user:${userId}:repos`, repos, ttlSeconds);
  }

  // Generic cache key builder
  public static buildKey(...parts: string[]): string {
    return parts.join(':');
  }
}



================================================
File: server/src/services/claude.service.ts
================================================
import { ApiError } from '../middleware/error.middleware';

export class ClaudeService {
  private apiKey: string;

  constructor() {
    this.apiKey = process.env.CLAUDE_API_KEY || '';
  }

  async analyzeCodeStructured(content: string): Promise<{
    insights: string[];
    vulnerabilities: string[];
    bestPractices: string[];
    specifications: string[];
  }> {
    try {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify({
          model: 'claude-3-opus-20240229',
          max_tokens: 4000,
          messages: [{
            role: 'user',
            content: `Analyze this code and provide structured insights in the following categories:
1. Best Practices: Identify code quality and maintainability aspects
2. Security: Find potential security vulnerabilities and risks
3. Architecture: Evaluate design patterns and architectural decisions
4. Specifications: Generate clear specifications for the code

Please provide the analysis in a clear, structured format.

Code to analyze:
${content}`,
          }],
        }),
      });

      if (!response.ok) {
        throw new ApiError(response.status === 401 ? 401 : 500, 'Failed to analyze code with Claude');
      }

      const result = await response.json();
      const analysis = result.content[0].text;

      return {
        insights: this.extractSection(analysis, 'Best Practices'),
        vulnerabilities: this.extractSection(analysis, 'Security'),
        bestPractices: this.extractSection(analysis, 'Architecture'),
        specifications: this.extractSection(analysis, 'Specifications'),
      };
    } catch (error) {
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError(500, 'Failed to analyze code');
    }
  }

  private extractSection(text: string, section: string): string[] {
    const sectionRegex = new RegExp(`${section}:([\\s\\S]*?)(?=\\n\\d\\.\\s|$)`);
    const match = text.match(sectionRegex);
    if (!match) return [];
    
    return match[1]
      .split('\n')
      .map(line => line.trim())
      .filter(line => line.length > 0);
  }
}

export const claudeService = new ClaudeService();



================================================
File: server/src/services/github.service.ts
================================================
import { Octokit } from '@octokit/rest';
import { ApiException } from '@codeinsight/common';
import logger from '../config/logger';

export class GitHubService {
  private octokit: Octokit;

  constructor(accessToken: string) {
    this.octokit = new Octokit({
      auth: accessToken,
    });
  }

  async getUser() {
    try {
      const { data } = await this.octokit.users.getAuthenticated();
      return {
        githubId: data.id,
        username: data.login,
        email: data.email,
        name: data.name,
        avatarUrl: data.avatar_url,
      };
    } catch (error) {
      logger.error('GitHub API Error - getUser:', error);
      throw new ApiException(
        'GITHUB_API_ERROR',
        'Failed to fetch GitHub user data'
      );
    }
  }

  async getRepository(owner: string, repo: string) {
    try {
      const { data } = await this.octokit.repos.get({
        owner,
        repo,
      });

      return {
        name: data.name,
        owner: data.owner.login,
        url: data.html_url,
        description: data.description,
        branch: data.default_branch,
        private: data.private,
      };
    } catch (error) {
      logger.error('GitHub API Error - getRepository:', error);
      throw new ApiException(
        'GITHUB_API_ERROR',
        'Failed to fetch repository data'
      );
    }
  }

  async listUserRepositories(page = 1, perPage = 30) {
    try {
      const { data } = await this.octokit.repos.listForAuthenticatedUser({
        sort: 'updated',
        direction: 'desc',
        per_page: perPage,
        page,
      });

      return data.map((repo) => ({
        name: repo.name,
        owner: repo.owner.login,
        url: repo.html_url,
        description: repo.description,
        branch: repo.default_branch,
        private: repo.private,
      }));
    } catch (error) {
      logger.error('GitHub API Error - listUserRepositories:', error);
      throw new ApiException(
        'GITHUB_API_ERROR',
        'Failed to fetch user repositories'
      );
    }
  }

  async getRepositoryContent(owner: string, repo: string, path: string, ref?: string) {
    try {
      const { data } = await this.octokit.repos.getContent({
        owner,
        repo,
        path,
        ref,
      });

      // Handle directory case
      if (Array.isArray(data)) {
        return data.map((item) => ({
          name: item.name,
          path: item.path,
          type: item.type,
          size: item.size,
          url: item.html_url,
        }));
      }

      // Handle file case
      if ('content' in data) {
        return {
          name: data.name,
          path: data.path,
          type: data.type,
          size: data.size,
          url: data.html_url,
          content: Buffer.from(data.content, 'base64').toString('utf-8'),
        };
      }

      throw new Error('Unsupported content type');
    } catch (error) {
      logger.error('GitHub API Error - getRepositoryContent:', error);
      throw new ApiException(
        'GITHUB_API_ERROR',
        'Failed to fetch repository content'
      );
    }
  }

  async createRepositoryWebhook(owner: string, repo: string, webhookUrl: string) {
    try {
      const { data } = await this.octokit.repos.createWebhook({
        owner,
        repo,
        config: {
          url: webhookUrl,
          content_type: 'json',
          secret: process.env.GITHUB_WEBHOOK_SECRET,
        },
        events: ['push', 'pull_request'],
        active: true,
      });

      return {
        id: data.id,
        url: data.config.url,
        events: data.events,
      };
    } catch (error) {
      logger.error('GitHub API Error - createRepositoryWebhook:', error);
      throw new ApiException(
        'GITHUB_API_ERROR',
        'Failed to create repository webhook'
      );
    }
  }
}



================================================
File: server/src/services/in-memory-store.ts
================================================
/**
 * In-memory data store for development purposes
 * Replaces MongoDB and Redis with simple in-memory structures
 */

// Types for our in-memory database
export interface User {
  id: string;
  username: string;
  name: string | null;
  email: string | null;
  avatarUrl: string;
  githubId: number;
  accessToken: string;
}

export interface Repository {
  id: string;
  userId: string;
  name: string;
  owner: string;
  description: string | null;
  url: string;
  language: string | null;
  stargazersCount: number;
  forksCount: number;
  createdAt: Date;
  updatedAt: Date;
}

export interface Analysis {
  id: string;
  repositoryId: string;
  userId: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  startedAt: Date;
  completedAt: Date | null;
  insights: Array<{
    id: string;
    title: string;
    description: string;
    severity: 'low' | 'medium' | 'high';
    category: string;
  }>;
  vulnerabilities: Array<{
    id: string;
    title: string;
    description: string;
    severity: 'low' | 'medium' | 'high';
    recommendation: string;
    location: string;
  }>;
  specification: {
    overview: string;
    components: Array<{
      name: string;
      description: string;
      responsibilities: string[];
    }>;
  } | null;
  createdAt: Date;
  updatedAt: Date;
}

// Singleton class to manage in-memory data
class InMemoryStore {
  private static instance: InMemoryStore;
  private users: Map<string, User>;
  private repositories: Map<string, Repository>;
  private analyses: Map<string, Analysis>;
  private cache: Map<string, { value: any; expiry: number | null }>;

  private constructor() {
    this.users = new Map();
    this.repositories = new Map();
    this.analyses = new Map();
    this.cache = new Map();
    this.seedDemoData();
  }

  public static getInstance(): InMemoryStore {
    if (!InMemoryStore.instance) {
      InMemoryStore.instance = new InMemoryStore();
    }
    return InMemoryStore.instance;
  }

  // User methods
  public getUsers(): User[] {
    return Array.from(this.users.values());
  }

  public getUserById(id: string): User | null {
    return this.users.get(id) || null;
  }

  public getUserByGithubId(githubId: number): User | null {
    return Array.from(this.users.values()).find(u => u.githubId === githubId) || null;
  }

  public createUser(user: User): User {
    this.users.set(user.id, user);
    return user;
  }

  public updateUser(id: string, updates: Partial<User>): User | null {
    const user = this.users.get(id);
    if (!user) return null;
    
    const updatedUser = { ...user, ...updates };
    this.users.set(id, updatedUser);
    return updatedUser;
  }

  public deleteUser(id: string): boolean {
    return this.users.delete(id);
  }

  // Repository methods
  public getRepositories(userId?: string): Repository[] {
    const repos = Array.from(this.repositories.values());
    return userId ? repos.filter(r => r.userId === userId) : repos;
  }

  public getRepositoryById(id: string): Repository | null {
    return this.repositories.get(id) || null;
  }

  public getRepositoryByOwnerAndName(userId: string, owner: string, name: string): Repository | null {
    return Array.from(this.repositories.values()).find(
      r => r.userId === userId && r.owner === owner && r.name === name
    ) || null;
  }

  public createRepository(repository: Repository): Repository {
    this.repositories.set(repository.id, repository);
    return repository;
  }

  public updateRepository(id: string, updates: Partial<Repository>): Repository | null {
    const repository = this.repositories.get(id);
    if (!repository) return null;
    
    const updatedRepository = { ...repository, ...updates };
    this.repositories.set(id, updatedRepository);
    return updatedRepository;
  }

  public deleteRepository(id: string): boolean {
    return this.repositories.delete(id);
  }

  // Analysis methods
  public getAnalyses(repositoryId?: string): Analysis[] {
    const analyses = Array.from(this.analyses.values());
    return repositoryId ? analyses.filter(a => a.repositoryId === repositoryId) : analyses;
  }

  public getAnalysisById(id: string): Analysis | null {
    return this.analyses.get(id) || null;
  }

  public createAnalysis(analysis: Analysis): Analysis {
    this.analyses.set(analysis.id, analysis);
    return analysis;
  }

  public updateAnalysis(id: string, updates: Partial<Analysis>): Analysis | null {
    const analysis = this.analyses.get(id);
    if (!analysis) return null;
    
    const updatedAnalysis = { ...analysis, ...updates };
    this.analyses.set(id, updatedAnalysis);
    return updatedAnalysis;
  }

  public deleteAnalysis(id: string): boolean {
    return this.analyses.delete(id);
  }

  // Cache methods (replacing Redis)
  public setCache(key: string, value: any, ttlSeconds?: number): void {
    const expiry = ttlSeconds ? Date.now() + ttlSeconds * 1000 : null;
    this.cache.set(key, { value, expiry });
  }

  public getCache<T>(key: string): T | null {
    const item = this.cache.get(key);
    
    if (!item) return null;
    
    // Check if expired
    if (item.expiry && item.expiry < Date.now()) {
      this.cache.delete(key);
      return null;
    }
    
    return item.value as T;
  }

  public deleteCache(key: string): boolean {
    return this.cache.delete(key);
  }

  public clearCache(): void {
    this.cache.clear();
  }

  // Seed with some demo data
  private seedDemoData(): void {
    // Add a demo user
    const demoUser: User = {
      id: 'user-1',
      username: 'devuser',
      name: 'Development User',
      email: 'dev@example.com',
      avatarUrl: 'https://avatars.githubusercontent.com/u/1?v=4',
      githubId: 1,
      accessToken: 'mock-token',
    };
    this.users.set(demoUser.id, demoUser);

    // Add some demo repositories
    const demoRepos: Repository[] = [
      {
        id: 'repo-1',
        userId: 'user-1',
        name: 'react',
        owner: 'facebook',
        description: 'A JavaScript library for building user interfaces',
        url: 'https://github.com/facebook/react',
        language: 'JavaScript',
        stargazersCount: 200000,
        forksCount: 40000,
        createdAt: new Date('2020-01-01'),
        updatedAt: new Date('2023-06-15'),
      },
      {
        id: 'repo-2',
        userId: 'user-1',
        name: 'typescript',
        owner: 'microsoft',
        description: 'TypeScript is a superset of JavaScript that compiles to clean JavaScript output',
        url: 'https://github.com/microsoft/typescript',
        language: 'TypeScript',
        stargazersCount: 85000,
        forksCount: 10000,
        createdAt: new Date('2020-03-15'),
        updatedAt: new Date('2023-05-20'),
      },
      {
        id: 'repo-3',
        userId: 'user-1',
        name: 'node',
        owner: 'nodejs',
        description: 'Node.js JavaScript runtime',
        url: 'https://github.com/nodejs/node',
        language: 'JavaScript',
        stargazersCount: 92000,
        forksCount: 24000,
        createdAt: new Date('2020-02-10'),
        updatedAt: new Date('2023-06-01'),
      },
    ];

    demoRepos.forEach(repo => this.repositories.set(repo.id, repo));

    // Add a demo analysis
    const demoAnalysis: Analysis = {
      id: 'analysis-1',
      repositoryId: 'repo-1',
      userId: 'user-1',
      status: 'completed',
      startedAt: new Date('2023-06-16T10:00:00Z'),
      completedAt: new Date('2023-06-16T10:05:00Z'),
      insights: [
        {
          id: 'insight-1',
          title: 'Extensive use of React Hooks',
          description: 'The codebase makes extensive use of React Hooks, which improves code reusability and simplifies state management.',
          severity: 'low',
          category: 'best_practice',
        },
        {
          id: 'insight-2',
          title: 'Missing error handling in asynchronous operations',
          description: 'Several components lack proper error handling for async operations, which could lead to unexpected behavior.',
          severity: 'medium',
          category: 'error_handling',
        },
      ],
      vulnerabilities: [
        {
          id: 'vuln-1',
          title: 'Potential XSS vulnerability',
          description: 'The application uses dangerouslySetInnerHTML without proper input sanitization.',
          severity: 'high',
          recommendation: 'Implement a proper sanitization library like DOMPurify before rendering user-generated content.',
          location: 'src/components/UserContent.jsx:42',
        },
      ],
      specification: {
        overview: 'React is a JavaScript library for building user interfaces, particularly single-page applications.',
        components: [
          {
            name: 'React Core',
            description: 'The core React library that provides component-based architecture.',
            responsibilities: ['Virtual DOM', 'Component lifecycle', 'State management'],
          },
          {
            name: 'React DOM',
            description: 'Renderer for web applications that enables React components to interact with the DOM.',
            responsibilities: ['DOM updates', 'Event handling', 'Browser compatibility'],
          },
        ],
      },
      createdAt: new Date('2023-06-16T10:00:00Z'),
      updatedAt: new Date('2023-06-16T10:05:00Z'),
    };

    this.analyses.set(demoAnalysis.id, demoAnalysis);
  }
}

export default InMemoryStore;



================================================
File: server/src/services/repository.service.ts
================================================
import { ApiException } from '@codeinsight/common';
import { RepositoryModel } from '../models/repository.model';
import { GitHubService } from './github.service';
import { UserModel } from '../models/user.model';
import logger from '../config/logger';

export class RepositoryService {
  async addRepository(userId: string, owner: string, name: string) {
    try {
      // Get user with GitHub access token
      const user = await UserModel.findById(userId).select('+accessToken');
      if (!user) {
        throw new ApiException('NOT_FOUND', 'User not found');
      }

      // Initialize GitHub service with user's token
      const githubService = new GitHubService(user.accessToken);

      // Fetch repository details from GitHub
      const repoDetails = await githubService.getRepository(owner, name);

      // Create repository in database
      const repository = await RepositoryModel.create({
        userId,
        ...repoDetails,
      });

      // Set up webhook for repository updates
      if (process.env.GITHUB_WEBHOOK_URL) {
        await githubService.createRepositoryWebhook(
          owner,
          name,
          process.env.GITHUB_WEBHOOK_URL
        );
      }

      return repository;
    } catch (error) {
      logger.error('Failed to add repository:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to add repository'
      );
    }
  }

  async getUserRepositories(userId: string, page = 1, limit = 10) {
    try {
      const skip = (page - 1) * limit;

      const [repositories, total] = await Promise.all([
        RepositoryModel.find({ userId })
          .sort({ updatedAt: -1 })
          .skip(skip)
          .limit(limit),
        RepositoryModel.countDocuments({ userId }),
      ]);

      return {
        repositories,
        pagination: {
          page,
          limit,
          total,
          pages: Math.ceil(total / limit),
        },
      };
    } catch (error) {
      logger.error('Failed to get user repositories:', error);
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to fetch repositories'
      );
    }
  }

  async getRepository(userId: string, repoId: string) {
    try {
      const repository = await RepositoryModel.findOne({
        _id: repoId,
        userId,
      });

      if (!repository) {
        throw new ApiException('NOT_FOUND', 'Repository not found');
      }

      return repository;
    } catch (error) {
      logger.error('Failed to get repository:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to fetch repository'
      );
    }
  }

  async syncWithGitHub(userId: string, repoId: string) {
    try {
      const repository = await this.getRepository(userId, repoId);
      const user = await UserModel.findById(userId).select('+accessToken');
      if (!user) {
        throw new ApiException('NOT_FOUND', 'User not found');
      }

      const githubService = new GitHubService(user.accessToken);
      const repoDetails = await githubService.getRepository(
        repository.owner,
        repository.name
      );

      // Update repository details
      Object.assign(repository, repoDetails);
      await repository.save();

      return repository;
    } catch (error) {
      logger.error('Failed to sync repository:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to sync repository'
      );
    }
  }

  async removeRepository(userId: string, repoId: string) {
    try {
      const result = await RepositoryModel.deleteOne({
        _id: repoId,
        userId,
      });

      if (result.deletedCount === 0) {
        throw new ApiException('NOT_FOUND', 'Repository not found');
      }

      return true;
    } catch (error) {
      logger.error('Failed to remove repository:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to remove repository'
      );
    }
  }

  async listRepositoryContent(
    userId: string,
    repoId: string,
    path = '',
    ref?: string
  ) {
    try {
      const repository = await this.getRepository(userId, repoId);
      const user = await UserModel.findById(userId).select('+accessToken');
      if (!user) {
        throw new ApiException('NOT_FOUND', 'User not found');
      }

      const githubService = new GitHubService(user.accessToken);
      return await githubService.getRepositoryContent(
        repository.owner,
        repository.name,
        path,
        ref
      );
    } catch (error) {
      logger.error('Failed to list repository content:', error);
      if (error instanceof ApiException) {
        throw error;
      }
      throw new ApiException(
        'INTERNAL_SERVER_ERROR',
        'Failed to fetch repository content'
      );
    }
  }
}





================================================
File: github-oauth-setup.md
================================================
# GitHub OAuth Setup Instructions

## 1. Update Server Environment (.env file)

Replace the contents of `/server/.env` with the following, using your GitHub credentials:

```
# Server Configuration
PORT=3030
NODE_ENV=development

# Database Configuration
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/codeinsight

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=Ov23li8iXRzrnU6OV2Ya
GITHUB_CLIENT_SECRET=8a90bc07534609020fbe78187d47bf8d486912bd
GITHUB_CALLBACK_URL=http://localhost:3030/api/auth/github/callback

# Claude AI Configuration
CLAUDE_API_KEY=your_claude_api_key

# JWT Configuration
JWT_SECRET=use_a_secure_random_string_at_least_32_chars
JWT_EXPIRES_IN=7d

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000  # 15 minutes
RATE_LIMIT_MAX_REQUESTS=100
```

## 2. Update Client Environment

Update `/client/.env.development` with your GitHub client ID:

```
# API Configuration
REACT_APP_API_URL=http://localhost:3030/api

# GitHub OAuth Configuration
REACT_APP_GITHUB_CLIENT_ID=Ov23li8iXRzrnU6OV2Ya
```

Make sure to replace `your_claude_api_key` and `use_a_secure_random_string_at_least_32_chars` with the actual values from your Claude AI application and a secure random string respectively.



================================================
File: heroku-build.js
================================================
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

console.log('Starting Heroku build process...');

// Build the client (frontend)
console.log('Building client...');
try {
  // First install client dependencies
  console.log('Installing client dependencies...');
  execSync('cd client && npm install', { stdio: 'inherit' });
  
  // Then build the client
  console.log('Building client application...');
  execSync('cd client && npm run build', { stdio: 'inherit' });
  console.log('Client build completed successfully');
  
  // Copy the client build to the root directory for serving
  const clientDistDir = path.join(__dirname, 'client', 'dist');
  const publicDir = path.join(__dirname, 'public');
  
  // Create public directory if it doesn't exist
  if (!fs.existsSync(publicDir)) {
    fs.mkdirSync(publicDir, { recursive: true });
  }
  
  // Copy all files from client/dist to public
  copyDirectory(clientDistDir, publicDir);
  console.log('Client build files copied to public directory');
  
} catch (error) {
  console.error('Client build failed:', error);
  process.exit(1);
}

console.log('Heroku build completed successfully');

// Helper function to recursively copy a directory
function copyDirectory(source, destination) {
  // Create destination directory if it doesn't exist
  if (!fs.existsSync(destination)) {
    fs.mkdirSync(destination, { recursive: true });
  }

  // Get all files and subdirectories in the source directory
  if (fs.existsSync(source)) {
    const entries = fs.readdirSync(source, { withFileTypes: true });

    for (const entry of entries) {
      const sourcePath = path.join(source, entry.name);
      const destinationPath = path.join(destination, entry.name);

      if (entry.isDirectory()) {
        // Recursively copy subdirectories
        copyDirectory(sourcePath, destinationPath);
      } else {
        // Copy files
        fs.copyFileSync(sourcePath, destinationPath);
      }
    }
  } else {
    console.warn(`Source directory ${source} does not exist`);
  }
}



================================================
File: index.html
================================================
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CodeIngest - Code Analysis Platform</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 2rem;
      line-height: 1.6;
      color: #333;
    }
    header {
      margin-bottom: 2rem;
      border-bottom: 1px solid #eee;
      padding-bottom: 1rem;
    }
    h1 {
      color: #2c3e50;
    }
    .card {
      background: #f9f9f9;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1.5rem 0;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .success {
      color: #4caf50;
    }
    .api-status {
      margin-top: 2rem;
    }
    pre {
      background: #f1f1f1;
      padding: 1rem;
      border-radius: 4px;
      overflow-x: auto;
    }
    button {
      background: #3498db;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1rem;
    }
    button:hover {
      background: #2980b9;
    }
  </style>
</head>
<body>
  <header>
    <h1>CodeIngest Application</h1>
    <p>Code analysis and insights platform</p>
  </header>

  <main>
    <div class="card">
      <h2><span class="success">✓</span> Successfully Deployed to Heroku</h2>
      <p>This is a simplified version of the application serving static content.</p>
      <p>The API is available at <code>/api</code> endpoints.</p>
    </div>
    
    <div class="card api-status">
      <h3>API Status</h3>
      <p>Check the current API status:</p>
      <button id="checkStatus">Check API Status</button>
      <div id="apiStatus" style="margin-top: 1rem;">Click the button to check status</div>
    </div>
  </main>

  <script>
    document.getElementById('checkStatus').addEventListener('click', function() {
      const statusElement = document.getElementById('apiStatus');
      statusElement.innerHTML = 'Loading...';
      
      fetch('/api/health')
        .then(response => response.json())
        .then(data => {
          statusElement.innerHTML = '<pre>' + JSON.stringify(data, null, 2) + '</pre>';
        })
        .catch(error => {
          statusElement.innerHTML = '<p style="color:red">Error connecting to API: ' + error.message + '</p>';
        });
    });
  </script>
</body>
</html>



================================================
File: package.json
================================================
{
  "name": "codeinsight",
  "version": "1.0.0",
  "private": true,
  "engines": {
    "node": "18.x",
    "npm": "9.x"
  },
  "scripts": {
    "start": "node server.js",
    "build": "node heroku-build.js",
    "heroku-postbuild": "npm install --no-shrinkwrap --no-package-lock"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "body-parser": "^1.20.2",
    "dotenv": "^16.3.1",
    "path": "^0.12.7",
    "axios": "^1.4.0",
    "uuid": "^9.0.0",
    "jsonwebtoken": "^9.0.0",
    "glob": "^10.0.0",
    "fs-extra": "^11.1.1",
    "child_process": "^1.0.2",
    "util": "^0.12.5",
    "os": "^0.1.2"
  }
}



================================================
File: Procfile
================================================
web: node server.js



================================================
File: reverence.txt
================================================

Entrypoint

async def ingest_async(
    source: str,
    max_file_size: int = 10 * 1024 * 1024,  # 10 MB
    include_patterns: Optional[Union[str, Set[str]]] = None,
    exclude_patterns: Optional[Union[str, Set[str]]] = None,
    branch: Optional[str] = None,
    output: Optional[str] = None,
) -> Tuple[str, str, str]:
    """
    Main entry point for ingesting a source and processing its contents.
    """
    repo_cloned = False

    try:
        query: IngestionQuery = await parse_query(
            source=source,
            max_file_size=max_file_size,
            from_web=False,
            include_patterns=include_patterns,
            ignore_patterns=exclude_patterns,
        )

        if query.url:
            selected_branch = branch if branch else query.branch  # prioritize branch argument
            query.branch = selected_branch

            clone_config = query.extract_clone_config()
            clone_coroutine = clone(clone_config)

            if inspect.iscoroutine(clone_coroutine):
                if asyncio.get_event_loop().is_running():
                    await clone_coroutine
                else:
                    asyncio.run(clone_coroutine)
            else:
                raise TypeError("clone did not return a coroutine as expected.")

            repo_cloned = True

        summary, tree, content = ingest_query(query)

        if output is not None:
            with open(output, "w", encoding="utf-8") as f:
                f.write(tree + "\n" + content)

        return summary, tree, content
    finally:
        # Clean up the temporary directory if it was created
        if repo_cloned:
            shutil.rmtree(TMP_BASE_PATH, ignore_errors=True)

            =====================================================
            =====================================================


    Ingestion 

    def ingest_query(query: IngestionQuery) -> Tuple[str, str, str]:
    """
    Run the ingestion process for a parsed query.
    """
    subpath = Path(query.subpath.strip("/")).as_posix()
    path = query.local_path / subpath

    apply_gitingest_file(path, query)

    if not path.exists():
        raise ValueError(f"{query.slug} cannot be found")

    if (query.type and query.type == "blob") or query.local_path.is_file():
        # Handle single file case
        if not path.is_file():
            raise ValueError(f"Path {path} is not a file")

        relative_path = path.relative_to(query.local_path)

        file_node = FileSystemNode(
            name=path.name,
            type=FileSystemNodeType.FILE,
            size=path.stat().st_size,
            file_count=1,
            path_str=str(relative_path),
            path=path,
        )

        if not file_node.content:
            raise ValueError(f"File {file_node.name} has no content")

        return format_node(file_node, query)

    # Handle directory case
    root_node = FileSystemNode(
        name=path.name,
        type=FileSystemNodeType.DIRECTORY,
        path_str=str(path.relative_to(query.local_path)),
        path=path,
    )

    stats = FileSystemStats()

    _process_node(
        node=root_node,
        query=query,
        stats=stats,
    )

    return format_node(root_node, query)

    ===============================================================
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    cloning 

    @async_timeout(TIMEOUT)
async def clone(config: CloneConfig) -> None:
    """
    Clone a repository to a local path based on the provided configuration.
    """
    # Extract and validate query parameters
    url: str = config.url
    local_path: str = config.local_path
    commit: Optional[str] = config.commit
    branch: Optional[str] = config.branch
    partial_clone: bool = config.subpath != "/"

    # Create parent directory if it doesn't exist
    parent_dir = Path(local_path).parent
    try:
        os.makedirs(parent_dir, exist_ok=True)
    except OSError as exc:
        raise OSError(f"Failed to create parent directory {parent_dir}: {exc}") from exc

    # Check if the repository exists
    if not await _check_repo_exists(url):
        raise ValueError("Repository not found, make sure it is public")

    clone_cmd = ["git", "clone", "--single-branch"]
    # TODO re-enable --recurse-submodules

    if partial_clone:
        clone_cmd += ["--filter=blob:none", "--sparse"]

    if not commit:
        clone_cmd += ["--depth=1"]
        if branch and branch.lower() not in ("main", "master"):
            clone_cmd += ["--branch", branch]

    clone_cmd += [url, local_path]

    # Clone the repository
    await _run_command(*clone_cmd)

    if commit or partial_clone:
        checkout_cmd = ["git", "-C", local_path]

        if partial_clone:
            subpath = config.subpath.lstrip("/")
            if config.blob:
                # When ingesting from a file url (blob/branch/path/file.txt), we need to remove the file name.
                subpath = str(Path(subpath).parent.as_posix())

            checkout_cmd += ["sparse-checkout", "set", subpath]

        if commit:
            checkout_cmd += ["checkout", commit]

        # Check out the specific commit and/or subpath
        await _run_command(*checkout_cmd)


        ====================================================================
        ====================================================================

        logic for inclusion or not in ingestion 

        def _should_include(path: Path, base_path: Path, include_patterns: Set[str]) -> bool:
    """
    Determine if the given file or directory path matches any of the include patterns.
    """
    try:
        rel_path = path.relative_to(base_path)
    except ValueError:
        # If path is not under base_path at all
        return False

    rel_str = str(rel_path)
    if path.is_dir():
        rel_str += "/"

    for pattern in include_patterns:
        if fnmatch(rel_str, pattern):
            return True
    return False


def _should_exclude(path: Path, base_path: Path, ignore_patterns: Set[str]) -> bool:
    """
    Determine if the given file or directory path matches any of the ignore patterns.
    """
    try:
        rel_path = path.relative_to(base_path)
    except ValueError:
        # If path is not under base_path at all
        return True

    rel_str = str(rel_path)
    for pattern in ignore_patterns:
        if pattern and fnmatch(rel_str, pattern):
            return True
    return False

    ===================================
    ===================================

    Processing node of files 

    def _process_node(
    node: FileSystemNode,
    query: IngestionQuery,
    stats: FileSystemStats,
) -> None:
    """
    Process a file or directory item within a directory.
    """
    if limit_exceeded(stats, node.depth):
        return

    for sub_path in node.path.iterdir():
        symlink_path = None
        if sub_path.is_symlink():
            if not _is_safe_symlink(sub_path, query.local_path):
                print(f"Skipping unsafe symlink: {sub_path}")
                continue

            symlink_path = sub_path
            sub_path = sub_path.resolve()

        if sub_path in stats.visited:
            print(f"Skipping already visited path: {sub_path}")
            continue

        stats.visited.add(sub_path)

        if query.ignore_patterns and _should_exclude(sub_path, query.local_path, query.ignore_patterns):
            continue

        if query.include_patterns and not _should_include(sub_path, query.local_path, query.include_patterns):
            continue

        if sub_path.is_file():
            _process_file(path=sub_path, parent_node=node, stats=stats, local_path=query.local_path)
        elif sub_path.is_dir():
            child_directory_node = FileSystemNode(
                name=sub_path.name,
                type=FileSystemNodeType.DIRECTORY,
                path_str=str(sub_path.relative_to(query.local_path)),
                path=sub_path,
                depth=node.depth + 1,
            )

            # rename the subdir to reflect the symlink name
            if symlink_path:
                child_directory_node.name = symlink_path.name
                child_directory_node.path_str = str(symlink_path)

            _process_node(
                node=child_directory_node,
                query=query,
                stats=stats,
            )
            node.children.append(child_directory_node)
            node.size += child_directory_node.size
            node.file_count += child_directory_node.file_count
            node.dir_count += 1 + child_directory_node.dir_count

        else:
            raise ValueError(f"Unexpected error: {sub_path} is neither a file nor a directory")

    node.sort_children()

    Understanding the App Size
You're absolutely right that the core ingestion logic is not overly complex. The reason the original app is large is because it handles several aspects beyond just ingestion:

Multiple interfaces: CLI, Python module, and web application
Error handling and edge cases: Dealing with various repository hosts, file types, encodings
Server components: Web routing, templating, API endpoints
Caching and optimization: For handling large repositories efficiently
Output formatting: For making the content LLM-friendly

For your TypeScript/React version, you could simplify this considerably by focusing on:

GitHub authentication
Repository cloning (using a Git library for Node.js)
File traversal and filtering (similar to the Python code above)
Claude API integration for the analysis

The core logic can be translated to TypeScript, and many of the web application concerns can be handled by React and modern web frameworks.
Would you like me to focus on implementing just this core ingestion logic in TypeScript? That would be a more manageable first step.


================================================
File: server.js
================================================
// Express server for Heroku deployment
const express = require('express');
const path = require('path');
const cors = require('cors');
const { v4: uuidv4 } = require('uuid');
const axios = require('axios');
const app = express();
const InMemoryStore = require('./services/in-memory-store');
const { ingestRepository } = require('./services/code-ingestion');

// Configuration
const PORT = process.env.PORT || 3000;
const store = InMemoryStore.getInstance();

// Middleware
app.use(express.json());
app.use(cors());

// Serve static files from the public directory (client build)
app.use(express.static(path.join(__dirname, 'public')));

// API endpoints
// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ 
    status: 'ok',
    environment: process.env.NODE_ENV || 'development',
    timestamp: new Date().toISOString(),
    message: 'CodeIngest API is running'
  });
});

// Get all repositories
app.get('/api/repositories', (req, res) => {
  const userId = store.getUsers()[0].id; // Using default user
  const repositories = store.getRepositories(userId);
  res.json({ repositories });
});

// Get a repository by id
app.get('/api/repositories/:id', (req, res) => {
  const repoId = req.params.id;
  const repository = store.getRepositoryById(repoId);
  
  if (!repository) {
    return res.status(404).json({ error: 'Repository not found' });
  }
  
  res.json({ repository });
});

// Add a new repository with owner/name
app.post('/api/repositories', (req, res) => {
  const { owner, name, url } = req.body;
  
  if (!owner || !name) {
    return res.status(400).json({ error: 'Owner and name are required' });
  }
  
  const userId = store.getUsers()[0].id;
  
  // Check if repository already exists
  const existingRepo = store.getRepositoryByOwnerAndName(userId, owner, name);
  
  if (existingRepo) {
    return res.status(409).json({ error: 'Repository already exists' });
  }
  
  // Create new repository
  const newRepo = {
    id: `repo-${uuidv4()}`,
    userId,
    owner,
    name,
    description: `${name} repository`,
    url: url || `https://github.com/${owner}/${name}`,
    language: 'JavaScript',
    stargazersCount: Math.floor(Math.random() * 1000),
    forksCount: Math.floor(Math.random() * 200),
    createdAt: new Date(),
    updatedAt: new Date()
  };
  
  const repository = store.createRepository(newRepo);
  return res.status(201).json({ repository });
});

// Ingest a public GitHub repository
app.post('/api/public-repositories', async (req, res) => {
  const { url } = req.body;
  
  if (!url) {
    return res.status(400).json({ error: 'GitHub repository URL is required' });
  }
  
  // Parse owner and name from GitHub URL
  let repoOwner, repoName;
  
  try {
    const githubUrlPattern = /github\.com\/([^\/]+)\/([^\/]+)/;
    const match = url.match(githubUrlPattern);
    
    if (!match) {
      return res.status(400).json({ error: 'Invalid GitHub URL format. Expected format: https://github.com/owner/repository' });
    }
    
    repoOwner = match[1];
    repoName = match[2].replace('.git', ''); // Remove .git if present
  } catch (error) {
    return res.status(400).json({ error: 'Could not parse GitHub URL' });
  }
  
  if (!repoOwner || !repoName) {
    return res.status(400).json({ error: 'Could not extract repository owner and name from URL' });
  }
  
  try {
    // Check if the repository exists on GitHub
    let githubResponse;
    try {
      githubResponse = await axios.get(`https://api.github.com/repos/${repoOwner}/${repoName}`);
    } catch (error) {
      if (error.response?.status === 404) {
        return res.status(404).json({ error: 'Repository not found on GitHub' });
      } else if (error.response?.status === 403) {
        return res.status(403).json({ error: 'This repository appears to be private. Please log in with GitHub to access private repositories.' });
      } else {
        throw error;
      }
    }
    
    const repoData = githubResponse.data;
    
    // Check if the repository is private
    if (repoData.private) {
      return res.status(403).json({ error: 'This is a private repository. Please log in with GitHub to access private repositories.' });
    }
    
    // Use our demo user ID for simplicity
    const userId = store.getUsers()[0].id;
    
    // Check if repository already exists in our system
    const existingRepo = store.getRepositoryByOwnerAndName(userId, repoOwner, repoName);
    
    if (existingRepo) {
      // If it exists but doesn't have ingested content, we could update it
      if (!existingRepo.ingestedContent) {
        console.log(`Adding content for existing repository: ${repoOwner}/${repoName}`);
        
        // Perform code ingestion
        const ingestionResult = await ingestRepository(url);
        
        // Update the repository with ingested content
        existingRepo.ingestedContent = {
          summary: ingestionResult.summary,
          tree: ingestionResult.tree,
          fullCode: ingestionResult.content,
          fileCount: ingestionResult.fileCount,
          sizeInBytes: ingestionResult.totalSizeBytes
        };
        
        store.updateRepository(existingRepo.id, existingRepo);
      }
      
      return res.status(200).json({ repository: existingRepo, message: 'Repository already exists' });
    }
    
    // Perform code ingestion process
    console.log(`Starting ingestion process for ${repoOwner}/${repoName}`);
    const ingestionResult = await ingestRepository(url);
    console.log(`Completed ingestion for ${repoOwner}/${repoName} with ${ingestionResult.fileCount} files`);
    
    // Create new repository with data from GitHub API
    const newRepo = {
      id: `repo-${uuidv4()}`,
      userId,
      owner: repoOwner,
      name: repoName,
      description: repoData.description || null,
      url: repoData.html_url,
      language: repoData.language || null,
      stargazersCount: repoData.stargazers_count,
      forksCount: repoData.forks_count,
      ingestedContent: {
        summary: ingestionResult.summary,
        tree: ingestionResult.tree,
        fullCode: ingestionResult.content,
        fileCount: ingestionResult.fileCount,
        sizeInBytes: ingestionResult.totalSizeBytes
      },
      createdAt: new Date()
    };
    
    const repository = store.createRepository(newRepo);
    
    // Create a new analysis record for this repository
    const analysisId = uuidv4();
    const analysis = {
      id: analysisId,
      repositoryId: repository.id,
      status: 'pending',
      createdAt: new Date(),
      completedAt: null,
      results: null
    };

    store.createAnalysis(analysis);
    
    // Simulate analysis completion after 5 seconds
    setTimeout(() => {
      const updatedAnalysis = {
        status: 'completed',
        completedAt: new Date(),
        results: [
          {
            id: uuidv4(),
            title: 'Good code organization',
            description: `The ${repository.name} codebase has a clear structure with separate concerns.`,
            severity: 'low',
            category: 'best_practice'
          },
          {
            id: uuidv4(),
            title: 'Consider refactoring some components',
            description: 'Several components could benefit from being broken down into smaller, more focused components.',
            severity: 'medium',
            category: 'refactoring'
          }
        ]
      };
      
      store.updateAnalysis(analysisId, updatedAnalysis);
      console.log(`Analysis completed for repository: ${repository.name}`);
    }, 5000);
    
    return res.status(201).json({ repository });
    
  } catch (error) {
    console.error('Error during repository ingestion:', error);
    return res.status(500).json({ error: 'An error occurred during repository ingestion' });
  }
});

// Get analyses for a repository
app.get('/api/repositories/:repositoryId/analyses', (req, res) => {
  const { repositoryId } = req.params;
  const repository = store.getRepositoryById(repositoryId);
  
  if (!repository) {
    return res.status(404).json({ error: 'Repository not found' });
  }
  
  const analyses = store.getAnalysesByRepositoryId(repositoryId);
  res.json({ analyses });
});

// Catch-all route for client-side routing
app.get('*', (req, res) => {
  if (req.url.startsWith('/api')) {
    return res.status(404).json({ error: 'API endpoint not found' });
  }
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Start the server
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
  console.log(`Environment: ${process.env.NODE_ENV || 'development'}`);
});



================================================
File: setup-env.sh
================================================
#!/bin/bash

# Create server .env file with placeholder values
cat > ./server/.env << EOL
# Server Configuration
PORT=3000
NODE_ENV=development

# Database Configuration
MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/codeinsight
REDIS_URL=redis://localhost:6379

# GitHub OAuth Configuration
GITHUB_CLIENT_ID=placeholder_github_id
GITHUB_CLIENT_SECRET=placeholder_github_secret
GITHUB_CALLBACK_URL=http://localhost:3000/api/auth/github/callback

# Claude AI Configuration
ANTHROPIC_API_KEY=placeholder_anthropic_key
CLAUDE_API_KEY=placeholder_claude_key

# JWT Configuration
JWT_SECRET=temporary_dev_jwt_secret_at_least_32_chars_long
JWT_EXPIRES_IN=7d

# Rate Limiting
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
EOL

# Create client .env file
cat > ./client/.env.development << EOL
# API Configuration
REACT_APP_API_URL=http://localhost:3000/api

# GitHub OAuth Configuration
REACT_APP_GITHUB_CLIENT_ID=placeholder_github_id
EOL

echo "Environment files created with placeholder values"
echo "Please update with your actual credentials before running in production"



================================================
File: Spec.txt
================================================
CodeIngest - Spec

Specification for Your Enhanced Version

Product Name: CodeInsight

Product Overview

CodeInsight is a web application that enhances code understanding by leveraging AI to analyze GitHub repositories. Users authenticate with GitHub to access both public and private repositories, then CodeInsight processes the codebase through Claude AI to produce insights, vulnerability reports, and product specifications.

Core Features

1. GitHub Authentication
     - OAuth integration with GitHub
    - Access to private and public repositories
    - User profile and repository management

1. Repository Ingestion
     - Clone and analyze GitHub repositories
    - Smart filtering of files (by patterns, size, and type)
    - Efficient handling of large codebases

1. AI Analysis with Claude
     - Code review with best practices assessment
    - Security vulnerability scanning
    - Identification of key files and components
    - Generation of product specifications

1. Visualization
     - Interactive file tree navigator
    - Code structure visualization
    - Key insights dashboard
    - Exportable reports in multiple formats

1. User Management
     - Save analysis history
    - Favorite repositories
    - Share analysis results

User Flow

6. User logs in with GitHub credentials
7. User selects a repository to analyze
8. System clones and processes the repository
9. Claude AI analyzes the codebase
10. System presents results in an interactive dashboard
11. User can explore detailed reports, share results, or export specifications

Technical Requirements

12. Frontend
     - React with TypeScript
    - Modern UI library (e.g., Material UI or Chakra UI)
    - Responsive design for mobile and desktop

1. Backend
     - Node.js with TypeScript
    - Express or NestJS framework
    - RESTful API architecture

1. Authentication
     - GitHub OAuth integration
    - JWT token-based authentication
    - Secure credential handling

1. AI Integration
     - Anthropic Claude API integration
    - Efficient content chunking for large repositories
    - Prompt engineering for code analysis

1. Data Storage
     - MongoDB for user data and analysis results
    - Redis for caching and rate-limiting
    - Temporary file storage for repository processing

1. Deployment
     - Docker containerization
    - Cloud hosting (AWS, GCP, or Azure)
    - CI/CD pipeline



================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true
  },
  "exclude": ["node_modules"]
}



================================================
File: .npmrc
================================================
legacy-peer-deps=true
node-linker=hoisted
public-hoist-pattern[]=*
install-strategy=shallow
prefer-install=npm



================================================
File: client/index.html
================================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; connect-src 'self' localhost:* ws:; font-src 'self' data: https: http:; img-src 'self' data: https: http:; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline';"
    />
    <meta
      name="description"
      content="CodeInsight - AI-powered code analysis and understanding"
    />
    <link rel="apple-touch-icon" href="/logo192.png" />
    <link rel="manifest" href="/manifest.json" />
    <title>CodeInsight</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="/src/index.tsx"></script>
  </body>
</html>



================================================
File: client/jest.config.js
================================================
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jsdom',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
  testMatch: ['**/__tests__/**/*.test.ts?(x)', '**/?(*.)+(spec|test).ts?(x)'],
  transform: {
    '^.+\\.tsx?$': 'ts-jest',
  },
  globals: {
    'ts-jest': {
      tsconfig: 'tsconfig.json',
    },
  },
};



========================